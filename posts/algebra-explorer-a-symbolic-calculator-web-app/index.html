<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Algebra Explorer - a symbolic calculator web app</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/algebra-explorer-a-symbolic-calculator-web-app.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Introducing a symbolic calculator built on the web stack and peeping under the hood</div><hr/><h2>Algebra Explorer - a symbolic calculator web app</h2><p class="taglist">Tags:<!-- --> <a href="/tags/algebra_explorer/">algebra explorer</a><a href="/tags/testing/">testing</a><a href="/tags/education/">education</a></p><div class="page-content"><div class="post" data-postid="algebraexplorer"><h3 id="the-project">The project</h3><p>For several years now I&#x27;ve tried to combine my programming self with my maths teacher alter ego by working on a symbolic calculator that would show the substeps of the manipulations made, to allow people to more easily understand the intricacies of algebra. Now I&#x27;m finally finished, and I am ever so happy to present to you - Algebra Explorer!</p><p style="text-align:center"><img src="/static/posts/algebra-explorer-a-symbolic-calculator-web-app/img/alexscreen.png"/></p><p>You can find out more by visiting <a href="http://www.algebraexplorer.com">the homepage</a>, but as it is a web app you can also try it out right here by clicking the button below!</p><p><button class="launchbutton" style="display:block;margin:0 auto">Launch Algebra Explorer</button></p><p>This post won&#x27;t talk too much about the pedagogical side or the app functionality, but instead relate how the app was built.</p><h3 id="payment-model">Payment model</h3><p>After trying out some different approaches I decided to make the app freely available online, and charge for an iOS version (Android planned too, but so far I haven&#x27;t managed to bring myself to fix that). Since the online version works fine in a mobile browser too the app really isn&#x27;t necessary, but useful if you want an offline version or just want to support the project.</p><p>Time will tell if this model is at all viable, but at this point I&#x27;m not too bothered by revenue - I&#x27;ll never ever get back what my spent unpaid time is worth anyway. And also it seemed like a nice way to leverage the power of the web stack.</p><h3 id="tech-stack">Tech stack</h3><p>As I have been toiling away at this project for years and years and <em>years</em> (I remember sketching out the prototype on the whiteboard of the school in Blacklake prison in 2007), the choices regarding building blocks are not what present day David would make. But, here we go:</p><ul><li><strong>CoffeeScript:</strong> Yeah, I know, I&#x27;m sorry. When I started (this version of the codebase) CS was all the craze, and I had my seat on the train. But I must say, diving down that rabbit hole definitely made me a stronger JS programmer!</li><li><strong>Backbone:</strong> Maybe not that bad of a fit, as my needs were rather specific and Backbone gave me lots of freedom.</li><li><strong>Vows:</strong> I&#x27;ll talk some more about the unit testing towards the end of this post.</li><li><strong>Mathjax:</strong> For displaying mathematics in browsers without native support for MathML.</li><li><strong>Cordova:</strong> Initially I used the <a href="https://build.phonegap.com/">phonegap build service</a>, but their repo size limit and other weirdness made me eventually install Cordova locally instead.</li></ul><p>Other than that, I built everything myself. This was more ignorance than pride; for example, had I known more about parsing theory I would have used a library as a foundation for my own instead of doing everything from scratch.</p><h3 id="algebraic-representation">Algebraic representation</h3><p>First off I designed my own data format for mathematics. It is very simple; everything expression has a <code>type</code>, some have a <code>val</code> and some have <code>objs</code> (meaning children). Here is a regular number:</p><pre><code class="hljs language-json">{<br/>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>,<br/>  <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">7</span><br/>}</code></pre><p>Here is the sum <code>x+pi/(4^3)</code>:</p><pre><code class="hljs language-json">{<br/>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;sum&quot;</span>,<br/>  <span class="hljs-attr">&quot;objs&quot;</span>: [<br/>    {<br/>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;variable&quot;</span>,<br/>      <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-string">&quot;x&quot;</span><br/>    },<br/>    {<br/>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;fraction&quot;</span>,<br/>      <span class="hljs-attr">&quot;objs&quot;</span>: [<br/>        {<br/>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;constant&quot;</span>,<br/>          <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-string">&quot;pi&quot;</span><br/>        },<br/>        {<br/>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;power&quot;</span>,<br/>          <span class="hljs-attr">&quot;objs&quot;</span>: [<br/>            {<br/>              <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>,<br/>              <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">4</span><br/>            },<br/>            {<br/>              <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>,<br/>              <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">3</span><br/>            }<br/>          ]<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</code></pre><h3 id="substeps-under-the-hood">Substeps under the hood</h3><p>The main pedagogical idea behind the app was to show substeps of everything, and not sweeping anything under the rug. Complex rules should break down into a small set of basic truths. I used this same approach under the hood; the basic truths, which I call atomic operations, all return a maths expression, while composite operations explicitly use other operations.</p><p>For example, consider the basic truth that we can always remove an exponent 1 from a power. No matter what the value of the base is, an exponent of 1 can be removed. Here is the source code for this atomic operation:</p><pre><code class="hljs language-coffeescript">oneExpPowerToBase = <span class="hljs-comment"># x^1 = x</span><br/>    info:<br/>        name: <span class="hljs-string">&quot;oneExpPowerToBase&quot;</span><br/>        effect: <span class="hljs-string">&quot;simplifying&quot;</span><br/>        opposite: <span class="hljs-string">&quot;raiseByOne&quot;</span><br/>        example: <span class="hljs-string">&quot;x^1&quot;</span><br/>        tags: [<span class="hljs-string">&quot;exponentiation&quot;</span>,<span class="hljs-string">&quot;power&quot;</span>,<span class="hljs-string">&quot;number1&quot;</span>,<span class="hljs-string">&quot;remove&quot;</span>,<span class="hljs-string">&quot;neutralelement&quot;</span>]<br/>        lesson: <span class="hljs-string">&quot;power101&quot;</span><br/>    prints:<br/>        errors: [<span class="hljs-string">&quot;expmustbeone&quot;</span>]<br/>    target:<br/>        type: <span class="hljs-string">&quot;power&quot;</span><br/>        validate: <span class="hljs-function"><span class="hljs-params">({deps,target:objs:[base,exp]})</span>-&gt;</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> deps.equal exp, one <span class="hljs-keyword">then</span> Err <span class="hljs-string">&quot;expmustbeone&quot;</span>, [<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> OK<br/>    perform: <span class="hljs-function"><span class="hljs-params">({target})</span>-&gt;</span><br/>        result: target.objs[<span class="hljs-number">0</span>]<br/>        beforemarks: [[<span class="hljs-number">1</span>]]</code></pre><p>Note how the <code>result</code> when calling <code>perform</code> will be <code>target.objs[0]</code>. Since the target of the operation is always a power, what is returned is the first child of the power, namely the base. And of course this is what remains if we &quot;remove&quot; the exponent.</p><p>Now consider the rule that if a power has an exponent of 0, it is equal to 1 (actually it is not quite that simple since the base cannot be 0 too, but never mind that for now). This is <em>not</em> a basic truth, but a consequence of the above rule and several other rules. Here&#x27;s what this looks like in the app:</p><p style="text-align:center"><img src="/static/posts/algebra-explorer-a-symbolic-calculator-web-app/img/alexsubsteps.png"/></p><p>And here is the source code for this operation, where you can see it explicitly calling each substep:</p><pre><code class="hljs language-coffeescript">zeroExpPowerToOne = <span class="hljs-comment"># x^0 = 1</span><br/>    info:<br/>        name: <span class="hljs-string">&quot;zeroExpPowerToOne&quot;</span><br/>        effect: <span class="hljs-string">&quot;simplifying&quot;</span><br/>        example: <span class="hljs-string">&quot;x^0&quot;</span><br/>        uses: [<span class="hljs-string">&quot;numToSum&quot;</span>,<span class="hljs-string">&quot;biSumExpPowToProd&quot;</span>,<span class="hljs-string">&quot;oneExpPowerToBase&quot;</span>,<span class="hljs-string">&quot;negExpFacProdToFrac&quot;</span>,<span class="hljs-string">&quot;sameNumerDenomFracToOne&quot;</span>]<br/>        tags: [<span class="hljs-string">&quot;exponentiation&quot;</span>,<span class="hljs-string">&quot;number1&quot;</span>,<span class="hljs-string">&quot;number0&quot;</span>,<span class="hljs-string">&quot;power&quot;</span>,<span class="hljs-string">&quot;collapse&quot;</span>,<span class="hljs-string">&quot;neutralelement&quot;</span>]<br/>        opposite: <span class="hljs-string">&quot;oneToZeroExpPower&quot;</span><br/>        lesson: <span class="hljs-string">&quot;powernegexp&quot;</span><br/>    prints:<br/>        errors: [<span class="hljs-string">&quot;expmustbezero&quot;</span>]<br/>    target:<br/>        type: <span class="hljs-string">&quot;power&quot;</span><br/>        validate: <span class="hljs-function"><span class="hljs-params">({deps,target:objs:[base,exp]})</span>-&gt;</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> deps.equal exp, zero <span class="hljs-keyword">then</span> Err <span class="hljs-string">&quot;expmustbezero&quot;</span>, [<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> OK<br/>    perform: <span class="hljs-function"><span class="hljs-params">(o)</span>-&gt;</span><br/>        o.<span class="hljs-keyword">do</span> <span class="hljs-string">&quot;numToSum&quot;</span>,<span class="hljs-string">&quot;turnzeroexpto1minus1&quot;</span>,aim:[<span class="hljs-number">1</span>],argument: Sum one,Neg one<br/>        o.<span class="hljs-keyword">do</span> <span class="hljs-string">&quot;biSumExpPowToProd&quot;</span>,<span class="hljs-string">&quot;splitpow&quot;</span><br/>        o.<span class="hljs-keyword">do</span> <span class="hljs-string">&quot;oneExpPowerToBase&quot;</span>,<span class="hljs-string">&quot;dropexp1&quot;</span>,aim:[<span class="hljs-number">0</span>]<br/>        o.<span class="hljs-keyword">do</span> <span class="hljs-string">&quot;negExpFacProdToFrac&quot;</span>,<span class="hljs-string">&quot;movetodenom&quot;</span>,selection:[[<span class="hljs-number">1</span>]]<br/>        o.<span class="hljs-keyword">do</span> <span class="hljs-string">&quot;sameNumerDenomFracToOne&quot;</span>,<span class="hljs-string">&quot;andcollapsefracto1&quot;</span><br/>        o.beforemark [[<span class="hljs-number">1</span>]]</code></pre><p>Modelling the code this way made it easier for me to show the substeps for the user, as the end result of a <code>simplify</code> call will be a nested object with each step info retained. Thus I can allow the UI to dig however deep the user wishes.</p><h3 id="localization">Localization</h3><p>Probably you&#x27;ve already gleaned that the app is bilingual. I manage localization through a simple literal system. For example, here&#x27;s the text content to go with the above operation:</p><pre><code class="hljs language-coffeescript">zeroExpPowerToOne:<br/>    id: <span class="hljs-number">2</span><br/>    sv:<br/>        name: <span class="hljs-string">&quot;omvandla potens till 1&quot;</span><br/>        explanation: <span class="hljs-string">&quot;Exponenten berättar hur många gånger vi multiplicerar basen med sig själv. Men har vi 0 faktorer så återstår bara det neutrala elementet för multiplikation, nämligen 1.&quot;</span><br/>        targets: <span class="hljs-string">&quot;en potens med exponent 0 och bas skiljd från 0&quot;</span><br/>        returns: <span class="hljs-string">&quot;det naturliga talet 1&quot;</span><br/>        effect: <span class="hljs-string">&quot;Detta är en förenklande regel, eftersom den kollapsar potensen till talet 1&quot;</span><br/>        steps:<br/>            turnzeroexpto1minus1: <span class="hljs-string">&quot;Först delar vi upp exponenten 0 i en summa, för att sedan kunna dela upp potensen.&quot;</span><br/>            splitpow: <span class="hljs-string">&quot;Vi delar upp potensen i två potensfaktorer. De nya potenserna får exponenterna 1 och -1.&quot;</span><br/>            dropexp1: <span class="hljs-string">&quot;Exponenten 1 tar vi bort.&quot;</span><br/>            movetodenom: <span class="hljs-string">&quot;Den andra potensen flyttar vi ner i nämnaren, vilket gör att exponenten byter tecken, blir 1 och försvinner!&quot;</span><br/>            andcollapsefracto1: <span class="hljs-string">&quot;Nu har vi ett bråk med identisk täljare och nämnare, vilket vi kollapsar till 1!&quot;</span><br/>    en:<br/>        name: <span class="hljs-string">&quot;transform power to 1&quot;</span><br/>        explanation: <span class="hljs-string">&quot;The exponent tells us how many times we multiply the base with itself. But if we have 0 factors we just get the neutral element of multiplication, namely 1.&quot;</span><br/>        targets: <span class="hljs-string">&quot;a power with exponent 0 and base not equal to 0&quot;</span><br/>        returns: <span class="hljs-string">&quot;the natural number 1&quot;</span><br/>        effect: <span class="hljs-string">&quot;This is a simplifying rule, since it collapses the power to the number 1&quot;</span><br/>        steps:<br/>            turnzeroexpto1minus1: <span class="hljs-string">&quot;First we split the exponent 0 into a sum, which will enable us to split the power.&quot;</span><br/>            splitpow: <span class="hljs-string">&quot;Now we split the power into two power factors. The new powers get the exponents 1 and -1.&quot;</span><br/>            dropexp1: <span class="hljs-string">&quot;The exponent 1 can be removed.&quot;</span><br/>            movetodenom: <span class="hljs-string">&quot;The other power we move into the denominator, which makes the exponent become 1 and disappear.&quot;</span><br/>            andcollapsefracto1: <span class="hljs-string">&quot;Now we have a fraction with identical numerator and denominator, which we can collapse to 1!&quot;</span></code></pre><p>Note how the <code>steps</code> keys correspond to the strings used in the <code>zeroExpPowerToOne</code> source.</p><p>Initially I was worried about keeping such large objects in memory - the one defined in this file, containing all operation descriptions and substep explanations, is over half a megabyte! But as it turned out, this proved to work rather smoothly even on lower end devices.</p><h3 id="regular-expressions-ftw">Regular expressions ftw</h3><p>As you can see in the screenshot up top, some terms inside explanations are clickable. Algebra Explorer has an integrated glossary - click the term to navigate to the definition for that term. This is done dynamically by defining a <code>matcher</code> for each glossary entry. Here&#x27;s the definition for the word <code>extract</code>:</p><pre><code class="hljs language-coffeescript">extract:<br/>    matcher:<br/>        en: <span class="hljs-string">&quot;extracte?d?i?n?g?&quot;</span><br/>        sv: <span class="hljs-string">&quot;br[yö]ta?e?r?s?( vi)? ut&quot;</span><br/>    headline:<br/>        en: <span class="hljs-string">&quot;extract&quot;</span><br/>        sv: <span class="hljs-string">&quot;bryta ut&quot;</span><br/>    description:<br/>        en: <span class="hljs-string">&quot;When we factorise an expression because we are interested in one of the resulting factors, we say that we extracted that factor.&quot;</span><br/>        sv: <span class="hljs-string">&quot;Om vi faktoriserar ett uttryck för att vi är intresserade av en av de resulterande faktorerna, så säger vi att vi har brytit ut (eller &#x27;extraherat&#x27;) den faktorn.&quot;</span></code></pre><p>This saved me from manually having to write the links, which would have made authoring the texts a real drag.</p><p>At first this didn&#x27;t work too well - sometimes there was a wording I hadn&#x27;t anticipated and the word wouldn&#x27;t be clickable, and other times words would be made clickable when they shouldn&#x27;t be as they meant something entirely different in that context. This got better over time as I got better at phrasing dexterous but still picky regexes.<br/><br/></p><p>I also made a special <code>MAKESAFE</code> matcher which wraps all matched content in a span, to prevent it from later being made clickable. This matcher used to be very complicated as it had to cater for lots of false positives, but now this is all that remains:</p><pre><code class="hljs language-coffeescript">MAKESAFE:<br/>    matcher:<br/>        en: <span class="hljs-string">&quot;introduced to|[01]\\.[0-9]+|number of times|any number of|the number of|a number of|1\\/|E?e?ven (though|if the)|introduced logic&quot;</span><br/>        sv: <span class="hljs-string">&quot;vardagligt tal|introduceras till|[01][\\,\\.][0-9]+|1\\/|introducerade logik&quot;</span></code></pre><h3 id="unit-testing-with-vows">Unit testing with Vows</h3><p>For unit testing my choice fell on <a href="http://vowsjs.org/">Vows</a>, which turned out to be a very good fit. The main advantage for me was that the test definitions in vows are object literals, which makes it easy to write helper functions (they call them &quot;macros&quot;) to clean up your tests.</p><p>Here is what it can look like, using the <code>mergeSameBaseFacs</code> operation as an example:</p><pre><code class="hljs language-coffeescript">tests.addBatch <span class="hljs-string">&quot;the mergeSameBaseFacs op&quot;</span>:<br/>    topic: <span class="hljs-function">-&gt;</span> tools.mergeSameBaseFacs<br/>    hasInfo: info<br/>        name: <span class="hljs-string">&quot;mergeSameBaseFacs&quot;</span><br/>        effect: <span class="hljs-string">&quot;simplifying&quot;</span><br/>        example: (str:<span class="hljs-string">&quot;x*y*x2&quot;</span>,selection:[[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]])<br/>    <span class="hljs-string">&quot;the target def says product&quot;</span>: targetIs <span class="hljs-string">&quot;product&quot;</span><br/>    <span class="hljs-string">&quot;the selection def&quot;</span>: selection<br/>        <span class="hljs-string">&quot;has min 2&quot;</span>: min <span class="hljs-number">2</span><br/>    <span class="hljs-string">&quot;the auto func&quot;</span>: auto<br/>        <span class="hljs-string">&quot;for no same base fac prod&quot;</span>: test<br/>            withTarget: (Product x, z, Power y,two)<br/>            <span class="hljs-string">&quot;we get err&quot;</span>: isError <span class="hljs-string">&quot;musthavesamebasefacs&quot;</span><br/>        <span class="hljs-string">&quot;for same base fac prod&quot;</span>: test<br/>            withTarget: (Product x, z, two, Power x,two)<br/>            <span class="hljs-string">&quot;we get correct obj&quot;</span>: isObj<br/>                selection: [[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]]<br/>        <span class="hljs-string">&quot;when neg hiding same&quot;</span>: test<br/>            withTarget: (Product x, z, two, Neg Power x,two)<br/>            <span class="hljs-string">&quot;we get correct obj&quot;</span>: isObj<br/>                selection: [[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]]<br/>    <span class="hljs-string">&quot;the perform func&quot;</span>: perform<br/>        <span class="hljs-string">&quot;when leftover facs&quot;</span>: test<br/>            withTarget: (Product x, z, (Power x,three), Power x,two)<br/>            withSelection: [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br/>            <span class="hljs-string">&quot;we get right answer&quot;</span>: resultIs (Product (Power x, Num <span class="hljs-number">6</span>), z)<br/>            <span class="hljs-string">&quot;sels are beforemarked&quot;</span>: beforemarks [[<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>]]<br/>            <span class="hljs-string">&quot;pow is aftermarked&quot;</span>: aftermarks [[<span class="hljs-number">0</span>]]<br/>        <span class="hljs-string">&quot;when no leftovers&quot;</span>: test<br/>            withTarget: (Product x, (Power x,three), Power x,two)<br/>            withSelection: [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]<br/>            <span class="hljs-string">&quot;we get right answer&quot;</span>: (resultIs Power x, Num <span class="hljs-number">6</span>)<br/>            <span class="hljs-string">&quot;and no aftermarks&quot;</span>: aftermarks <span class="hljs-literal">undefined</span><br/>        <span class="hljs-string">&quot;when non-numeric&quot;</span>: test<br/>            withTarget: (Product x, Power x, y)<br/>            withSelection: [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br/>            <span class="hljs-string">&quot;we get right answer&quot;</span>: (resultIs Power x, Sum one, y)<br/>        <span class="hljs-string">&quot;when multinonnumeric&quot;</span>: test<br/>            withTarget: (Product (Power two, x), (Power two, y), Power two, z)<br/>            withSelection: [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]<br/>            <span class="hljs-string">&quot;we get right ans&quot;</span>: (resultIs Power two, Sum x,y,z)<br/>        <span class="hljs-string">&quot;when partly numeric&quot;</span>: test<br/>            withTarget: (Product (Power two, three), (Power two, y), two)<br/>            withSelection: [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]<br/>            <span class="hljs-string">&quot;we get right ans&quot;</span>: (resultIs Power two,Sum (Num <span class="hljs-number">4</span>), y)<br/>        <span class="hljs-string">&quot;when one negation&quot;</span>: test<br/>            withTarget: (Product (Power two, three), (Neg Power two, y), two)<br/>            withSelection: [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]<br/>            <span class="hljs-string">&quot;we get right ans&quot;</span>: (resultIs Neg Power two,Sum (Num <span class="hljs-number">4</span>), y)</code></pre><p>Combined with the added readability of CoffeeScript, this really makes for some sleek tests!</p><h3 id="wrapping-up">Wrapping up</h3><p>When I started, part of my motivation was to show that it was possible to build this kind of thing with JavaScript. That&#x27;s not a point that needs to be made anymore, and there are already several other CAS implementations built on the web stack.</p><p>Still, I am rather proud of my creation! Sure, it contains many rough edges, the UI isn&#x27;t that intuitive, and many times the fact that this is a one man show shines through. But for those who get over the initial threshold it seems the app can really help them grokk algebra. We&#x27;re starting now to roll it out for the maths students in the Swedish prisons, and I hope teachers outside the walls will catch on too. Time will tell.</p><p>And also the code is really pretty. :)</p><p>Anyhow, if you have an interest then please do give <a href="http://www.algebraexplorer.com">Algebra Explorer</a> a spin! Any and all feedback much appreciated!</p><script type="text/javascript">
  document.querySelector(".launchbutton").addEventListener("click",function(e){
    var win = window.open("https://krawaller.github.io/math3/www/index.html?demo=1&seed=284716495&source=fbtab&language=en",'targetWindow','toolbar=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=320,height=568');
    win = win || {};
    win.height = 568;
    win.width = 320;
    e.preventDefault();
  });
</script></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/algebra-explorer-a-symbolic-calculator-web-app","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/algebra-explorer-a-symbolic-calculator-web-app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/algebra-explorer-a-symbolic-calculator-web-app.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>