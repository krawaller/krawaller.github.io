<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Explaining callbags via TypeScript definitions</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/explaining-callbags-via-typescript-definitions.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/><style id="__jsx-564446276">.YEP.jsx-564446276{color:green;font-weight:bold;}.NOPE.jsx-564446276{color:red;font-weight:bold;}.sup.jsx-564446276{vertical-align:baseline;position:relative;font-size:70%;top:-0.6em;}.note.jsx-564446276{font-size:0.8em;}</style></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Understanding callbags by splitting them into types with individual TypeScript definitions</div><hr/><h2>Explaining callbags via TypeScript definitions</h2><p class="taglist">Tags:<!-- --> <a href="/tags/callbags/">callbags</a><a href="/tags/typescript/">typescript</a></p><div class="page-content"><div data-postid="callbagtypescript" class="jsx-564446276 post"><h3 id="premise" class="jsx-564446276">Premise</h3><p class="jsx-564446276">I&#x27;ve already written an <a class="jsx-564446276" href="/posts/callbags-introduction/">introduction to callbags</a>, but I wasn&#x27;t completely happy - it still feels like the initial threshold to grokk what&#x27;s going on is rather high. Callbags are a rather simple concept, but communicating the nuances is surprisingly difficult.</p><p class="jsx-564446276">In this post I make a second attempt, this time via splitting up the lifecycle and definining precise TypeScript interfaces for the various parts. You are assumed to have read the introductory post and/or be familiar with the <a href="https://github.com/callbag/callbag" class="jsx-564446276">callbags spec</a>.</p><h3 id="the-official-callbag-typing" class="jsx-564446276">The official callbag typing</h3><p class="jsx-564446276">The spec defines a callbag as...</p><blockquote class="jsx-564446276"><p class="jsx-564446276">a function of signature (TypeScript syntax:)<br class="jsx-564446276"/> <code class="jsx-564446276">(type: 0 | 1 | 2, payload?: any) =&gt; void</code></p></blockquote><p class="jsx-564446276">This is further reflected in the <a href="https://github.com/callbag/callbag/blob/master/types.d.ts" class="jsx-564446276">official <code class="jsx-564446276">types.d.ts</code> file</a> which looks like this (slightly abbreviated):</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs"><span class="jsx-564446276 hljs-builtin-name">export</span><span class="jsx-564446276 hljs-built_in"> type </span>START = 0;<br class="jsx-564446276"/><span class="jsx-564446276 hljs-builtin-name">export</span><span class="jsx-564446276 hljs-built_in"> type </span>DATA = 1;<br class="jsx-564446276"/><span class="jsx-564446276 hljs-builtin-name">export</span><span class="jsx-564446276 hljs-built_in"> type </span>END = 2;<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-builtin-name">export</span><span class="jsx-564446276 hljs-built_in"> type </span>Callbag = (type: START | DATA | END, payload?: any) =&gt; void;<br class="jsx-564446276"/><span class="jsx-564446276 hljs-builtin-name">export</span><span class="jsx-564446276 hljs-built_in"> type </span>Factory = (<span class="jsx-564446276 hljs-built_in">..</span>.args: Array&lt;any&gt;) =&gt; Callbag;<br class="jsx-564446276"/><span class="jsx-564446276 hljs-builtin-name">export</span><span class="jsx-564446276 hljs-built_in"> type </span>Operator = (<span class="jsx-564446276 hljs-built_in">..</span>.args: Array&lt;any&gt;) =&gt; (source: Callbag) =&gt; Callbag;</code></pre><p class="jsx-564446276">The trouble is that <code class="jsx-564446276">START</code>, <code class="jsx-564446276">DATA</code> and <code class="jsx-564446276">END</code> are <em class="jsx-564446276">not always</em> valid as the first parameter to a callbag. Exactly what we can send depends on where we are in the life cycle.</p><p class="jsx-564446276">Or, phrased differently: it depends on <em class="jsx-564446276">from where we got the callbag we&#x27;re calling</em>. This can be surmised from the written text of the spec, but it isn&#x27;t reflected in the typings.</p><h3 id="the-holy-trinity-of-callbags" class="jsx-564446276">The holy trinity of callbags</h3><p class="jsx-564446276">Things become more clear when you realise that there are actually <strong class="jsx-564446276">three different kinds of callbags</strong>:</p><ul class="jsx-564446276"><li class="jsx-564446276"><strong class="jsx-564446276">Source</strong>: The initial callbag function that a sink can subscribe to</li><li class="jsx-564446276"><strong class="jsx-564446276">Sink talkback</strong> The callbag sent to the source by the sink when subscribing</li><li class="jsx-564446276"><strong class="jsx-564446276">Source talkback</strong> The callbag sent in response to the sink talkback by the source talkback</li></ul><p class="jsx-564446276">These three kinds of callbags expect to be called in different ways. In other words, they have different signatures! Here&#x27;s a lowdown in table form on how they can be called:</p><table class="jsx-564446276"><thead class="jsx-564446276"><tr class="jsx-564446276"><th class="jsx-564446276">call</th><th class="jsx-564446276">source</th><th class="jsx-564446276">source talkback</th><th class="jsx-564446276">sink talkback</th></tr></thead><tbody class="jsx-564446276"><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(0, callbag)</code></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td></tr><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(1)</code></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span><span class="jsx-564446276 sup">1</span></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td></tr><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(1, data)</code></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td></tr><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(2)</code></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td></tr><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(2, error)</code></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span><span class="jsx-564446276 sup">2</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td></tr></tbody></table><span class="jsx-564446276 note"><span class="jsx-564446276 sup">1</span> If the source is pullable <br class="jsx-564446276"/><span class="jsx-564446276 sup">2</span> A source likely doesn&#x27;t care why the sink terminates, so you could argue for a &quot;no&quot; here</span><p class="jsx-564446276">And, applying the notion of &quot;three different kinds of callbags&quot; consistently, we should split the first row in the table...</p><table class="jsx-564446276"><thead class="jsx-564446276"><tr class="jsx-564446276"><th class="jsx-564446276">call</th><th class="jsx-564446276">source</th><th class="jsx-564446276">source talkback</th><th class="jsx-564446276">sink talkback</th></tr></thead><tbody class="jsx-564446276"><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(0, callbag)</code></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td></tr></tbody></table><p class="jsx-564446276">...to this:</p><table class="jsx-564446276"><thead class="jsx-564446276"><tr class="jsx-564446276"><th class="jsx-564446276">call</th><th class="jsx-564446276">source</th><th class="jsx-564446276">source talkback</th><th class="jsx-564446276">sink talkback</th></tr></thead><tbody class="jsx-564446276"><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(0, sinkTalkback)</code></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td></tr><tr class="jsx-564446276"><td class="jsx-564446276"><code class="jsx-564446276">(0, sourceTalkback)</code></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 NOPE">no</span></td><td class="jsx-564446276"><span class="jsx-564446276 YEP">yes</span></td></tr></tbody></table><p class="jsx-564446276">Let&#x27;s take our three different types one by one and see if our observations match some real-world code. And, if they do, create individual type definitions for them!</p><h3 id="sources" class="jsx-564446276">Sources</h3><p class="jsx-564446276">According to our table, a <em class="jsx-564446276">source</em> callbag only ever expects to be called with <code class="jsx-564446276">(0, sinkTalkback)</code>. This is reflected in the code for many source implementations in that the first parameter is called <code class="jsx-564446276">start</code>, not <code class="jsx-564446276">t</code>.</p><p class="jsx-564446276">For example, look at Staltz&#x27; <a href="https://github.com/staltz/callbag-interval" class="jsx-564446276">callbag-interval</a> source:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript"><span class="jsx-564446276 hljs-keyword">const</span> interval = <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">period</span> =&gt;</span> <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start, sink</span>) =&gt;</span> {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">if</span> (start !== <span class="jsx-564446276 hljs-number">0</span>) <span class="jsx-564446276 hljs-keyword">return</span>;<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">let</span> i = <span class="jsx-564446276 hljs-number">0</span>;<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">const</span> id = <span class="jsx-564446276 hljs-built_in">setInterval</span>(<span class="jsx-564446276 hljs-function">() =&gt;</span> {<br class="jsx-564446276"/>    sink(<span class="jsx-564446276 hljs-number">1</span>, i++);<br class="jsx-564446276"/>  }, period);<br class="jsx-564446276"/>  sink(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">t</span> =&gt;</span> {<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">2</span>) <span class="jsx-564446276 hljs-built_in">clearInterval</span>(id);<br class="jsx-564446276"/>  });<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">The signature in the code is called <code class="jsx-564446276">(start, sink)</code>, and if <code class="jsx-564446276">start</code> doesn&#x27;t equal <code class="jsx-564446276">0</code> we bail because nothing else makes sense at this point. This function will never receive data requests <code class="jsx-564446276">(1)</code> or terminations <code class="jsx-564446276">(2)</code> - those will be sent to a source talkback.</p><p class="jsx-564446276">In other words, a TypeScript definition for a <code class="jsx-564446276">Source</code> could be:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> Source = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start: START, sinkTalkback: SinkTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;</code></pre><h3 id="source-talkbacks" class="jsx-564446276">Source talkbacks</h3><p class="jsx-564446276">In our table we noted <code class="jsx-564446276">(1)</code> and <code class="jsx-564446276">(2)</code> (and maybe <code class="jsx-564446276">(2, error)</code>) as valid calls to the <em class="jsx-564446276">source talkback</em>. Peeking back at the code for <code class="jsx-564446276">interval</code>, the source talkback is implemented as:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript">t =&gt; {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">2</span>) <span class="jsx-564446276 hljs-built_in">clearInterval</span>(id);<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">It only ever handles terminations <code class="jsx-564446276">(2)</code>. This makes sense since <code class="jsx-564446276">interval</code> isn&#x27;t pullable, so it doesn&#x27;t care about data requests <code class="jsx-564446276">(1)</code>.</p><p class="jsx-564446276">To take a pullable example, here&#x27;s Staltz&#x27; <a href="https://github.com/staltz/callbag-from-pull-stream" class="jsx-564446276">callbag-from-pull-stream</a>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript"><span class="jsx-564446276 hljs-keyword">const</span> fromPullStream = <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">read</span> =&gt;</span> <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start, sink</span>) =&gt;</span> {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">if</span> (start !== <span class="jsx-564446276 hljs-number">0</span>) <span class="jsx-564446276 hljs-keyword">return</span>;<br class="jsx-564446276"/>  sink(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">t, d</span>) =&gt;</span> {<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-comment">// &lt;--- source talkback</span><br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">1</span>)<br class="jsx-564446276"/>      read(<span class="jsx-564446276 hljs-literal">null</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">end, data</span>) =&gt;</span> {<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">if</span> (end === <span class="jsx-564446276 hljs-literal">true</span>) sink(<span class="jsx-564446276 hljs-number">2</span>);<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">else</span> <span class="jsx-564446276 hljs-keyword">if</span> (end) sink(<span class="jsx-564446276 hljs-number">2</span>, end);<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">else</span> sink(<span class="jsx-564446276 hljs-number">1</span>, data);<br class="jsx-564446276"/>      });<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">2</span>) read(d || <span class="jsx-564446276 hljs-literal">true</span>, <span class="jsx-564446276 hljs-function">() =&gt;</span> {});<br class="jsx-564446276"/>  });<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">Here we can see the source talkback definition dealing with both <code class="jsx-564446276">(1)</code> and <code class="jsx-564446276">(2)</code>.</p><p class="jsx-564446276">Let&#x27;s now tie up our observations about the source talkback into a TypeScript definition:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript">type SourceTalkback = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">type: DATA | END, payload: any</span>) =&gt;</span> <span class="jsx-564446276 hljs-keyword">void</span>;</code></pre><p class="jsx-564446276">If we accept the notion that a source is never interested in why a sink terminates, we could skip the second parameter since it is only used for <code class="jsx-564446276">(2, error)</code>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript">type SourceTalkback = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">type: DATA | END</span>) =&gt;</span> <span class="jsx-564446276 hljs-keyword">void</span>;</code></pre><p class="jsx-564446276">We could also potentially split this into separate interfaces for pullable and listenable sources:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript">type PullableSourceTalkback = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">type: DATA | END</span>) =&gt;</span> <span class="jsx-564446276 hljs-keyword">void</span>;<br class="jsx-564446276"/>type ListenableSourceTalkback = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">type: END</span>) =&gt;</span> <span class="jsx-564446276 hljs-keyword">void</span>;</code></pre><p class="jsx-564446276">And then define a <code class="jsx-564446276">SourceTalkback</code> as being one or the other:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript">type SourceTalkback = PullableSourceTalkback | ListenableSourceTalkback;</code></pre><h3 id="sink-talkbacks" class="jsx-564446276">Sink talkbacks</h3><p class="jsx-564446276">Now for the third and final type - sink talkbacks! In our table we had them listed as accepting all three types <code class="jsx-564446276">START</code>, <code class="jsx-564446276">DATA</code> and <code class="jsx-564446276">END</code>. This makes sense since they...</p><ul class="jsx-564446276"><li class="jsx-564446276">must be greeted back by the source with a source talkback, which means <code class="jsx-564446276">START</code></li><li class="jsx-564446276">will receive data from the source, which means <code class="jsx-564446276">DATA</code></li><li class="jsx-564446276">can be terminated by the source, which means <code class="jsx-564446276">END</code></li></ul><p class="jsx-564446276">Here is Staltz&#x27; <a href="https://github.com/staltz/callbag-for-each" class="jsx-564446276">callbag-for-each</a>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript"><span class="jsx-564446276 hljs-keyword">const</span> forEach = <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">operation</span> =&gt;</span> <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">source</span> =&gt;</span> {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">let</span> talkback;<br class="jsx-564446276"/>  source(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">t, d</span>) =&gt;</span> {<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-comment">// &lt;--- sink talkback</span><br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">0</span>) talkback = d;<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">1</span>) operation(d);<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">1</span> || t === <span class="jsx-564446276 hljs-number">0</span>) talkback(<span class="jsx-564446276 hljs-number">1</span>);<br class="jsx-564446276"/>  });<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">It doesn&#x27;t handle <code class="jsx-564446276">(2)</code>, but it doesn&#x27;t need to - if there&#x27;s no more data coming in, nothing more will happen. There&#x27;s nothing going on downstream from <code class="jsx-564446276">forEach</code> and nothing to clean up, so we don&#x27;t need to act.</p><p class="jsx-564446276">To see termination handling we must look at something that needs to clean up. Or something that isn&#x27;t at the end of the chain - in other words, a sink used by an operator to make a new source! As an example, here is my <a href="https://github.com/krawaller/callbag-latest" class="jsx-564446276">callbag-latest</a> which turns a listenable source into a pullable one:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript"><span class="jsx-564446276 hljs-keyword">const</span> latest = <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">listenable</span> =&gt;</span> <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start, sink</span>) =&gt;</span> {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">if</span> (start !== <span class="jsx-564446276 hljs-number">0</span>) <span class="jsx-564446276 hljs-keyword">return</span>;<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">let</span> ltalkback;<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">let</span> latestValue;<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">let</span> hasLatestValue = <span class="jsx-564446276 hljs-literal">false</span>;<br class="jsx-564446276"/>  listenable(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">lt, ld</span>) =&gt;</span> {<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-comment">// &lt;--- sink talkback</span><br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (lt === <span class="jsx-564446276 hljs-number">0</span>) {<br class="jsx-564446276"/>      ltalkback = ld;<br class="jsx-564446276"/>      sink(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">st, sd</span>) =&gt;</span> {<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">if</span> (st === <span class="jsx-564446276 hljs-number">1</span> &amp;&amp; hasLatestValue) sink(<span class="jsx-564446276 hljs-number">1</span>, latestValue);<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">if</span> (st === <span class="jsx-564446276 hljs-number">2</span>) ltalkback(<span class="jsx-564446276 hljs-number">2</span>, sd);<br class="jsx-564446276"/>      });<br class="jsx-564446276"/>    }<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (lt === <span class="jsx-564446276 hljs-number">1</span>) {<br class="jsx-564446276"/>      latestValue = ld;<br class="jsx-564446276"/>      hasLatestValue = <span class="jsx-564446276 hljs-literal">true</span>;<br class="jsx-564446276"/>    }<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (lt === <span class="jsx-564446276 hljs-number">2</span>) sink(<span class="jsx-564446276 hljs-number">2</span>, ld);<br class="jsx-564446276"/>  });<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">Here we can clearly see the sink talkback handling all three cases including terminations <code class="jsx-564446276">(2)</code> - although, as is often the case, the only thing it does with the termination is to pass it down the chain.</p><p class="jsx-564446276">Since sink talkbacks actually handle all three cases, they are the first kind of callbag that matches the official callbag typing!</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SinkTalkback = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params"><span class="jsx-564446276 hljs-keyword">type</span>: START | DATA | END, payload?: <span class="jsx-564446276 hljs-built_in">any</span></span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;</code></pre><p class="jsx-564446276">We can clarify the second parameter by splitting this into three different types and joining them via an <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" class="jsx-564446276">intersection type</a> using <code class="jsx-564446276">&amp;</code>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SinkTalkback = (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start: START, sourceTalkback: SourceTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp;<br class="jsx-564446276"/>  (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">deliver: DATA, data: <span class="jsx-564446276 hljs-built_in">any</span></span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp;<br class="jsx-564446276"/>  (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">terminate: END, error?: <span class="jsx-564446276 hljs-built_in">any</span></span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>);</code></pre><p class="jsx-564446276">The extra parenthesises around the three function types are needed for TypeScript not to throw a fit.</p><p class="jsx-564446276">This gives us rather nice intellisense help in a TypeScript setting:</p><p class="jsx-564446276"><img src="/static/posts/explaining-callbags-via-typescript-definitions/img/callbag-typing.gif" alt="" class="jsx-564446276"/></p><p class="jsx-564446276">In fact, that&#x27;s so nice that we should split up <code class="jsx-564446276">SourceTalkback</code> in the same way so that it too gets separate parameter names per call type:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SourceTalkback = (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">request: DATA</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp; (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">terminate: END</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>);</code></pre><h3 id="source-vs-source-talkback" class="jsx-564446276">Source VS source talkback</h3><p class="jsx-564446276">Our tour of the three different kinds of callbags - source, source talkback and sink talkback - is now concluded!</p><p class="jsx-564446276">But let&#x27;s zoom out and discuss the difference between <em class="jsx-564446276">source</em> and <em class="jsx-564446276">source talkback</em> for a bit. Our TypeScript definition for <code class="jsx-564446276">Source</code> was:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> Source = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start: START, sinkTalkback: SinkTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;</code></pre><p class="jsx-564446276">...and <code class="jsx-564446276">Source talkback</code>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SourceTalkback = (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">request: DATA</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp; (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">terminate: END</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>);</code></pre><p class="jsx-564446276">But what exactly does the spec say about <strong class="jsx-564446276">source</strong>? Well:</p><blockquote class="jsx-564446276"><p class="jsx-564446276">a callbag which is expected to deliver data</p></blockquote><p class="jsx-564446276">Hmm. Who is it that delivers data - is it the <code class="jsx-564446276">Source</code> or the <code class="jsx-564446276">SourceTalkback</code>? Well, that actually depends!</p><p class="jsx-564446276">In a <em class="jsx-564446276">pullable source</em> it is the <em class="jsx-564446276">source talkback</em>. Check again at the source for <code class="jsx-564446276">fromPullStream</code>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript"><span class="jsx-564446276 hljs-keyword">const</span> fromPullStream = <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">read</span> =&gt;</span> <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start, sink</span>) =&gt;</span> {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">if</span> (start !== <span class="jsx-564446276 hljs-number">0</span>) <span class="jsx-564446276 hljs-keyword">return</span>;<br class="jsx-564446276"/>  sink(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">t, d</span>) =&gt;</span> {<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-comment">// &lt;--- source talkback</span><br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">1</span>)<br class="jsx-564446276"/>      read(<span class="jsx-564446276 hljs-literal">null</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">end, data</span>) =&gt;</span> {<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">if</span> (end === <span class="jsx-564446276 hljs-literal">true</span>) sink(<span class="jsx-564446276 hljs-number">2</span>);<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">else</span> <span class="jsx-564446276 hljs-keyword">if</span> (end) sink(<span class="jsx-564446276 hljs-number">2</span>, end);<br class="jsx-564446276"/>        <span class="jsx-564446276 hljs-keyword">else</span> sink(<span class="jsx-564446276 hljs-number">1</span>, data); <span class="jsx-564446276 hljs-comment">// &lt;--- delivery call</span><br class="jsx-564446276"/>      });<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">2</span>) read(d || <span class="jsx-564446276 hljs-literal">true</span>, <span class="jsx-564446276 hljs-function">() =&gt;</span> {});<br class="jsx-564446276"/>  });<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">The <code class="jsx-564446276">sink(1, data)</code> call takes place inside the source talkback. But if we look at a listenable source like <code class="jsx-564446276">interval</code>...</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript"><span class="jsx-564446276 hljs-keyword">const</span> interval = <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">period</span> =&gt;</span> <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start, sink</span>) =&gt;</span> {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">if</span> (start !== <span class="jsx-564446276 hljs-number">0</span>) <span class="jsx-564446276 hljs-keyword">return</span>;<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">let</span> i = <span class="jsx-564446276 hljs-number">0</span>;<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">const</span> id = <span class="jsx-564446276 hljs-built_in">setInterval</span>(<span class="jsx-564446276 hljs-function">() =&gt;</span> {<br class="jsx-564446276"/>    sink(<span class="jsx-564446276 hljs-number">1</span>, i++); <span class="jsx-564446276 hljs-comment">// &lt;---- delivery call</span><br class="jsx-564446276"/>  }, period);<br class="jsx-564446276"/>  sink(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">t</span> =&gt;</span> {<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-comment">// &lt;---- source talkback</span><br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">2</span>) <span class="jsx-564446276 hljs-built_in">clearInterval</span>(id);<br class="jsx-564446276"/>  });<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">...you&#x27;ll note the <code class="jsx-564446276">sink(1, data)</code> call is taking place inside the <em class="jsx-564446276">source</em>.</p><p class="jsx-564446276">This means that the word <strong class="jsx-564446276">source</strong> as defined in the spec encompasses <em class="jsx-564446276">both</em> <code class="jsx-564446276">Source</code> and <code class="jsx-564446276">SourceTalkback</code>. The concept includes both typings. Or you could argue that <code class="jsx-564446276">SourceTalkback</code> is an implementation detail of <code class="jsx-564446276">Source</code>.</p><p class="jsx-564446276">Either way, using the name <code class="jsx-564446276">Source</code> for a type seems like needless confusion potential. To mitigate that, let&#x27;s rename what we&#x27;ve defined as <code class="jsx-564446276">Source</code> and call it <code class="jsx-564446276">SourceInitiator</code> instead:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SourceInitiator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start: START, sinkTalkback: SinkTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;</code></pre><p class="jsx-564446276">Now the words make more sense - the definition of <em class="jsx-564446276">source</em> in the spec includes both concepts of <code class="jsx-564446276">SourceInitiator</code> and <code class="jsx-564446276">SourceTalkback</code>.</p><h3 id="sink-vs-sink-talkback" class="jsx-564446276">Sink VS sink talkback</h3><p class="jsx-564446276">The obvious next question - what, then, is the difference between a sink and a sink talkback? What even <em class="jsx-564446276">is</em> a sink?</p><p class="jsx-564446276">The spec simply says...</p><blockquote class="jsx-564446276"><p class="jsx-564446276">a callbag which is expected to be delivered data</p></blockquote><p class="jsx-564446276">...which clearly fits the sink talkback. That will always be what receives the data. However, that doesn&#x27;t answer our question of what a sink actually is.</p><p class="jsx-564446276">But if a <code class="jsx-564446276">SourceInitiator</code> is what provides a <code class="jsx-564446276">SourceTalkback</code>, an interesting thing might be to look at what provides the <code class="jsx-564446276">SinkTalkback</code>! Let&#x27;s look again at <code class="jsx-564446276">forEach</code>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript"><span class="jsx-564446276 hljs-keyword">const</span> forEach = <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">operation</span> =&gt;</span> <span class="jsx-564446276 hljs-function"><span class="jsx-564446276 hljs-params">source</span> =&gt;</span> {<br class="jsx-564446276"/>  <span class="jsx-564446276 hljs-keyword">let</span> talkback;<br class="jsx-564446276"/>  source(<span class="jsx-564446276 hljs-number">0</span>, <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">t, d</span>) =&gt;</span> {<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-comment">// &lt;--- sink talkback</span><br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">0</span>) talkback = d;<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">1</span>) operation(d);<br class="jsx-564446276"/>    <span class="jsx-564446276 hljs-keyword">if</span> (t === <span class="jsx-564446276 hljs-number">1</span> || t === <span class="jsx-564446276 hljs-number">0</span>) talkback(<span class="jsx-564446276 hljs-number">1</span>);<br class="jsx-564446276"/>  });<br class="jsx-564446276"/>};</code></pre><p class="jsx-564446276">The <code class="jsx-564446276">sourceInitiator(0, sinkTalkback)</code> call takes place inside a function that takes a source parameter and returns nothing. Is perhaps that a sink? Or, by the previous logic, a sink initiator?</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SinkInitiator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">source: SourceInitiator</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;</code></pre><p class="jsx-564446276">I&#x27;d say yes, that is a sink (initiator)!</p><p class="jsx-564446276">Except this time the typescript definition isn&#x27;t as helpful, since it doesn&#x27;t encode the fact that to be a <code class="jsx-564446276">SinkInitiator</code> you must also <em class="jsx-564446276">call the passed source</em> in a specific way. It is kind of implied through the type of the passed in <code class="jsx-564446276">SourceInitiator</code>, but, still.</p><p class="jsx-564446276">Perhaps we can make the implication stronger still by calling it <code class="jsx-564446276">SinkConnector</code> instead of <code class="jsx-564446276">SinkInitiator</code>? Yeah, let&#x27;s do that!</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-javascript">type SinkConnector = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">source: SourceInitiator</span>) =&gt;</span> <span class="jsx-564446276 hljs-keyword">void</span>;</code></pre><p class="jsx-564446276">However, we can note that every single usage of the word &quot;sink&quot; in the spec fits what we&#x27;ve labeled as a <code class="jsx-564446276">SinkTalkback</code>. In other words, we could have called that a <code class="jsx-564446276">Sink</code>. But it seems nice to be constistent in suffixing the type for a callbag that is passed in to another callbag with <code class="jsx-564446276">-Talkback</code>.</p><h3 id="operators-and-sinks" class="jsx-564446276">Operators and sinks</h3><p class="jsx-564446276">In the official typings, <em class="jsx-564446276">operators</em> are defined as:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> Operator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> (source: Callbag) =&gt; Callbag;</code></pre><p class="jsx-564446276">We can replace <code class="jsx-564446276">Callbag</code> with what we&#x27;ve called <code class="jsx-564446276">SourceInitiator</code>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> Operator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params"><br class="jsx-564446276"/>  ...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;<br class="jsx-564446276"/></span>) =&gt;</span> (source: SourceInitiator) =&gt; SourceInitiator;</code></pre><p class="jsx-564446276">So what&#x27;s returned from calling the operators with some arguments is <em class="jsx-564446276">almost</em> a sink connector, except it returns <code class="jsx-564446276">SourceInitiator</code> instead of <code class="jsx-564446276">void</code>!</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SinkConnector = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">source: SourceInitiator</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;<br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> ReturnedFromOp = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">source: SourceInitiator</span>) =&gt;</span> SourceInitiator;</code></pre><p class="jsx-564446276">Do we want to be able to say that an operator returns a sink connector? Or should we invent a new concept for this?</p><p class="jsx-564446276">I&#x27;m voting for the former - it makes sense to say that an operator returns a sink connector. We can do that by merging the two types above thusly:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SinkConnector = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">source: SourceInitiator</span>) =&gt;</span> SourceInitiator | <span class="jsx-564446276 hljs-built_in">void</span>;</code></pre><p class="jsx-564446276">This has four benefits:</p><ul class="jsx-564446276"><li class="jsx-564446276">no need for a separate type to describe what is returned by an operator</li><li class="jsx-564446276">we can type operators who <em class="jsx-564446276">don&#x27;t</em> return anything (in other words, an operator for a sink)</li><li class="jsx-564446276">we can type sinks who returns a source initiator, allowing for the chain to continue</li><li class="jsx-564446276">the chainability is now visible in the typings!</li></ul><p class="jsx-564446276">So our revised type for <code class="jsx-564446276">Operator</code> is now:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs"><span class="jsx-564446276 hljs-keyword">type</span> Operator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> SinkConnector</code></pre><h3 id="factories" class="jsx-564446276">Factories</h3><p class="jsx-564446276">The official typings also had a typing for <code class="jsx-564446276">Factory</code>:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> Factory = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> Callbag;</code></pre><p class="jsx-564446276">We can now clarify that into:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs"><span class="jsx-564446276 hljs-keyword">type</span> SourceFactory = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> SourceInitiator;</code></pre><p class="jsx-564446276">What about a <code class="jsx-564446276">SinkFactory</code>? It turns out we don&#x27;t need one - a <code class="jsx-564446276">SinkFactory</code> is simply an <code class="jsx-564446276">Operator</code> that returns a <code class="jsx-564446276">SinkConnector</code> that <em class="jsx-564446276">doesn&#x27;t</em> return a <code class="jsx-564446276">SourceInitiator</code>!</p><h3 id="the-new-typings" class="jsx-564446276">The new typings</h3><p class="jsx-564446276">Here are all our new typings collected:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-comment">// Source</span><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SourceFactory = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> SourceInitiator;<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SourceInitiator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start: START, sinkTalkback: SinkTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SourceTalkback = (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">request: DATA</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp; (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">terminate: END</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>);<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-comment">// Sink</span><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SinkConnector = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">source: SourceInitiator</span>) =&gt;</span> SourceInitiator | <span class="jsx-564446276 hljs-built_in">void</span>;<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SinkTalkback = (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start: START, sourceTalkback: SourceTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp;<br class="jsx-564446276"/>  (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">deliver: DATA, data: <span class="jsx-564446276 hljs-built_in">any</span></span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp;<br class="jsx-564446276"/>  (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">terminate: END, error?: <span class="jsx-564446276 hljs-built_in">any</span></span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>);<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-comment">// Other</span><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> Operator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> SinkConnector;</code></pre><p class="jsx-564446276">However, if we want to avoid using types that haven&#x27;t been defined yet, we can look at the dependency graph of the types...</p><p class="jsx-564446276"><img src="/static/posts/explaining-callbags-via-typescript-definitions/diagrams/callbag-typedefs.svg" alt="" class="jsx-564446276"/></p><p class="jsx-564446276">...and reorder them backwards according to that:</p><pre class="jsx-564446276"><code class="jsx-564446276 hljs language-typescript"><span class="jsx-564446276 hljs-keyword">type</span> SourceTalkback = (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">request: DATA</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp; (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">terminate: END</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>);<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SinkTalkback = (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">start: START, sourceTalkback: SourceTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp;<br class="jsx-564446276"/>  (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">deliver: DATA, data: <span class="jsx-564446276 hljs-built_in">any</span></span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>) &amp;<br class="jsx-564446276"/>  (<span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">terminate: END, error?: <span class="jsx-564446276 hljs-built_in">any</span></span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>);<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SourceInitiator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params"><span class="jsx-564446276 hljs-keyword">type</span>: START, payload: SinkTalkback</span>) =&gt;</span> <span class="jsx-564446276 hljs-built_in">void</span>;<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SinkConnector = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">source: SourceInitiator</span>) =&gt;</span> SourceInitiator | <span class="jsx-564446276 hljs-built_in">void</span>;<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> SourceFactory = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> SourceInitiator;<br class="jsx-564446276"/><br class="jsx-564446276"/><span class="jsx-564446276 hljs-keyword">type</span> Operator = <span class="jsx-564446276 hljs-function">(<span class="jsx-564446276 hljs-params">...args: <span class="jsx-564446276 hljs-built_in">Array</span>&lt;<span class="jsx-564446276 hljs-built_in">any</span>&gt;</span>) =&gt;</span> SinkConnector;</code></pre><h3 id="reaping-the-rewards" class="jsx-564446276">Reaping the rewards</h3><p class="jsx-564446276">With these typings down we can use them as a very precise vocabulary for explaining the process of using callbags!</p><p class="jsx-564446276">Here&#x27;s the setup and handshake:</p><ol class="jsx-564446276"><li class="jsx-564446276">We call a <code class="jsx-564446276">SinkConnector</code> passing in a <code class="jsx-564446276">SourceInitiator</code>: <code class="jsx-564446276">sinkConnector(sourceInitiator)</code></li><li class="jsx-564446276">The <code class="jsx-564446276">SourceInitiator</code> is called with a <code class="jsx-564446276">SinkTalkback</code>: <code class="jsx-564446276">sourceInitiator(0,sinkTalkback)</code></li><li class="jsx-564446276">The <code class="jsx-564446276">SinkTalkback</code> is called with a <code class="jsx-564446276">SourceTalkback</code>: <code class="jsx-564446276">sinkTalkback(0,sourceTalkback)</code></li></ol><p class="jsx-564446276">And data passing:</p><ol class="jsx-564446276"><li class="jsx-564446276">The <code class="jsx-564446276">SourceTalkback</code> is called with a request for data (if pullable): <code class="jsx-564446276">sourceTalkback(1)</code></li><li class="jsx-564446276">The <code class="jsx-564446276">SinkTalkback</code> is called with data delivery: <code class="jsx-564446276">sinkTalkback(1,data)</code></li></ol><p class="jsx-564446276">And termination:</p><ul class="jsx-564446276"><li class="jsx-564446276">The <code class="jsx-564446276">SourceTalkback</code> can be called to terminate the relationship: <code class="jsx-564446276">sourceTalkback(2)</code></li><li class="jsx-564446276">The <code class="jsx-564446276">SinkTalkback</code> can be called to terminate the relationship: <code class="jsx-564446276">sinkTalkback(2)</code></li><li class="jsx-564446276">The <code class="jsx-564446276">SinkTalkback</code> can be called to terminate the relationship due to an error: <code class="jsx-564446276">sinkTalkback(2,error)</code></li></ul><h3 id="wrapping-up" class="jsx-564446276">Wrapping up</h3><p class="jsx-564446276">Creating the types definitely helped me cement my own understanding of callbags, but I&#x27;m not sure if they have a pedagogic power in general. I can only hope you found this instructive, otherwise you just made a very long journey for nothing. :)</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/explaining-callbags-via-typescript-definitions","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/explaining-callbags-via-typescript-definitions" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/explaining-callbags-via-typescript-definitions.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>