<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Writing Jasmine tests in a JSON format</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/writing-jasmine-tests-in-a-json-format.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">This post presents a function for writing Jasmine tests in a JSON format, along with an accompanying mini review of Test-Driven JavaScript Development</div><hr/><h2>Writing Jasmine tests in a JSON format</h2><p class="taglist">Tags:<!-- --> <a href="/tags/testing/">testing</a><a href="/tags/jasmine/">jasmine</a><a href="/tags/sinon/">sinon</a><a href="/tags/immutablejs/">immutablejs</a><a href="/tags/review/">review</a></p><div class="page-content"><div class="post" data-postid="jasminetestingpattern"><h3 id="prelude">Prelude</h3><p>This post assumes familiarity with <a href="http://jasmine.github.io/">Jasmine</a> in particular and TDD with JavaScript in general. If you need a primer on the latter you can do no better than <a href="http://tddjs.com/">Test-Driven JavaScript Development</a> by fellow metalhead <a href="http://cjohansen.no/">Christian Johansen</a>.</p><p><img src="/static/posts/writing-jasmine-tests-in-a-json-format/img/booktddjs.png" alt="Jasmine output"/></p><p>The book came out way back in 2010, and there has been <a href="http://shop.oreilly.com/product/0636920025245.do">several</a> <a href="http://shop.oreilly.com/product/0636920024699.do">books</a> <a href="http://shop.oreilly.com/product/0636920028277.do">written</a> <a href="https://www.packtpub.com/web-development/javascript-unit-testing">since</a>. But I&#x27;ve read them all and my mind none of them comes even close to TDDJS, which not only gives you a thorough understanding for how tests work but also makes you <em>think</em> in a TDD way. And as an added bonus it increases your general JS fu while doing it!</p><p>All in all an impressively well-written book which has aged really well.</p><h3 id="the-premise">The premise</h3><p>Anyhow! Imagine you are building a maths library consisting of an object literal with lots of methods. Say we add a method for testing whether a number is divisible by another number (that is, the result is an integer):</p><pre><code class="hljs language-javascript">myMathLib.isDivisible(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// false</span><br/>myMathLib.isDivisible(<span class="hljs-number">12</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// true</span></code></pre><p>The corresponding Jasmine test might look something like this:</p><pre><code class="hljs language-javascript">describe(<span class="hljs-string">&quot;myMathLib&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>    describe(<span class="hljs-string">&quot;the isDivisible method&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>        describe(<span class="hljs-string">&quot;when numbers are divisible&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>            it(<span class="hljs-string">&quot;returns true&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                expect(myMathLib.isDivisible(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>)).toEqual(<span class="hljs-literal">true</span>);<br/>            });<br/>        });<br/>        describe(<span class="hljs-string">&quot;when numbers aren&#x27;t divisible&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>            it(<span class="hljs-string">&quot;returns false&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                expect(myMathLib.isDivisible(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)).toEqual(<span class="hljs-literal">false</span>);<br/>            });<br/>        });<br/>    });<br/>});</code></pre><p>If we run these tests in a browser, Jasmine outputs this:</p><p><img src="/static/posts/writing-jasmine-tests-in-a-json-format/img/generatedmanualjasmine.png" alt="Jasmine output"/></p><p>Jasmine makes for very readable code, and very clear output. The problem? Although easy and clear, I still find that the Jasmine code contains enough cruft that I sometimes choose not to write tests because it is too much of a hassle. This new <code>isDivisible</code> method I intend to add is so simple, surely I don&#x27;t really need tests for that...</p><h3 id="the-literal-tester">The literal tester</h3><p>The <code>literaltester</code> function introduced in this blog post reduces the cruft by allowing you to define the tests in a simple JSON format. Here&#x27;s the above example again, rephrased to use the JSON literal method:</p><pre><code class="hljs language-javascript">literaltester(<span class="hljs-string">&quot;my math lib&quot;</span>,myMathLib,{<br/>    <span class="hljs-string">&quot;isDivisible(dividend,divisor)&quot;</span>: {<br/>        <span class="hljs-string">&quot;when divisor can divide dividend&quot;</span>: {<br/>            <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;it says aye&quot;</span>,<br/>            <span class="hljs-attr">dividend</span>: <span class="hljs-number">48</span>,<br/>            <span class="hljs-attr">divisor</span>: <span class="hljs-number">8</span>,<br/>            <span class="hljs-attr">expected</span>: <span class="hljs-literal">true</span><br/>        },<br/>        <span class="hljs-string">&quot;when divisor cannot divide&quot;</span>: {<br/>            <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;it says nay&quot;</span>,<br/>            <span class="hljs-attr">dividend</span>: <span class="hljs-number">47</span>,<br/>            <span class="hljs-attr">divisor</span>: <span class="hljs-number">3</span>,<br/>            <span class="hljs-attr">expected</span>: <span class="hljs-literal">false</span><br/>        } <br/>    }<br/>});</code></pre><p>The difference might not be earth shattering but I still find the reduced cruft to be liberating, both when it comes to readability and to actually bring yourself to write/update tests!</p><p>Under the hood <code>literaltester</code> will make the relevant calls to <code>describe</code>, <code>it</code> and <code>expect</code>, rendering an identical output:</p><p><img src="/static/posts/writing-jasmine-tests-in-a-json-format/img/generatedjasmine.png" alt="Jasmine output"/></p><h3 id="the-api-in-detail">The API in detail</h3><p>The signature of the function looks like this:</p><pre><code class="hljs language-javascript">literaltester(description,literal,tests,I)</code></pre><p>Here&#x27;s a lowdown of the arguments:</p><ul><li><strong>description:</strong> a very short description of the literal used for the toplevel <code>describe</code> call</li><li><strong>literal:</strong> the literal whose methods we want to test</li><li><strong>tests:</strong> a JSON object defining our tests</li><li><strong>I:</strong> an optional instance of <a href="https://facebook.github.io/immutable-js/">ImmutableJS</a>, more on this later</li></ul><p>As you saw in the example, the keys in the <code>tests</code> literal are string representations of the signature for the methods we are testing. Here are the possible keys for the test spec:</p><ul><li><strong>expected:</strong> The value we want the tested method to return</li><li><strong>description:</strong> An optional short description used for the <code>it</code> call. If not provided a generic string is used.</li><li><strong>&lt;parameter&gt;:</strong> By using the same parameter names you put in the signature you can provide values for the various arguments</li></ul><h3 id="testing-context-method-usage">Testing context method usage</h3><p>Let&#x27;s say our <code>isDivisible</code> method is supposed to make a <code>this.processValue</code> call for each argument, and then use the return value for the calculation. Presumably this method takes care of parsing strings or something of the like. We can test for that by providing a <code>context</code> for the test:</p><pre><code class="hljs language-javascript">literaltester(<span class="hljs-string">&quot;my math lib&quot;</span>,myMathLib,{<br/>    <span class="hljs-string">&quot;isDivisible(dividend,divisor)&quot;</span>: {<br/>        <span class="hljs-string">&quot;when divisor can divide dividend&quot;</span>: {<br/>            <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;it says aye&quot;</span>,<br/>            <span class="hljs-attr">dividend</span>: <span class="hljs-number">48</span>,<br/>            <span class="hljs-attr">divisor</span>: <span class="hljs-number">8</span>,<br/>            <span class="hljs-attr">expected</span>: <span class="hljs-literal">true</span>,<br/>            <span class="hljs-attr">context</span>: {<br/>                <span class="hljs-attr">processValue</span>: {<br/>                    <span class="hljs-attr">returnsarg</span>: <span class="hljs-number">0</span>,<br/>                    <span class="hljs-attr">expectedargs</span>: [[<span class="hljs-number">48</span>],[<span class="hljs-number">8</span>]]<br/>                }<br/>            }<br/>        },<br/>        <span class="hljs-string">&quot;when divisor cannot divide&quot;</span>: {<br/>            <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;it says nay&quot;</span>,<br/>            <span class="hljs-attr">dividend</span>: <span class="hljs-number">47</span>,<br/>            <span class="hljs-attr">divisor</span>: <span class="hljs-number">3</span>,<br/>            <span class="hljs-attr">expected</span>: <span class="hljs-literal">false</span><br/>        } <br/>    }<br/>});</code></pre><p>Here&#x27;s the generated output from Jasmine:</p><p><img src="/static/posts/writing-jasmine-tests-in-a-json-format/img/generatedjasminewithcontext.png" alt="Jasmine output"/></p><p>As you can see <code>literaltester</code> will generate a spy for each method in <code>context</code>, and test for <code>expectedargs</code> (if provided).</p><p>Here&#x27;s the possible values for each context method. None are required, but you should only provide 1 of the first 4: </p><ul><li><strong>returns:</strong> A value that the spy will return when called.</li><li><strong>returnsarg:</strong> An index used to <code>return arguments[index]</code></li><li><strong>returnseries:</strong> An array of values where the first call will return index 0, then index 1, etc</li><li><strong>method:</strong> A function to be used as spy, where you can return whatever you want</li><li><strong>expectedargs:</strong> An array of arrays of expected arguments</li></ul><p>Since it is rather common to expect context methods return something that was initially passed to the method we are testing, I made a syntax to allow pointing to those parameters by using <code>&quot;@&lt;parametername&gt;&quot;</code>. In other words the <code>context</code> above could be defined like this:</p><pre><code class="hljs language-json">{<br/>    processValue: {<br/>        returnsarg: 0,<br/>        expectedargs: [[&quot;@dividend&quot;],[&quot;@divisor&quot;]]<br/>    }<br/>}</code></pre><h3 id="testing-functional-libraries-using-immutablejs">Testing functional libraries using ImmutableJS</h3><p>As you saw previously you can provide an <a href="https://facebook.github.io/immutable-js/">ImmutableJS</a> instance to <code>literaltester</code> as an optional fourth argument. If you do, all array and object parameters, expected return values and spy return values are converted using <code>I.fromJS</code>.</p><p>Here&#x27;s a super short primer if this is all nonsense:</p><ol><li>Mutation makes for complex code and should be avoided</li><li>If no mutation occurs, all we need to test is return value and context method calls (which incidentally is why <code>literaltester</code> only does these two things)</li><li>Avoiding mutation in JS is sometimes hard as it means copying objects etc. ImmutableJS helps with this!</li></ol><h3 id="source-code">Source code</h3><p>Here&#x27;s the full source code for <code>literaltester</code>. It is a bit crude as it uses Sinon instead of Jasmine&#x27;s internal spy API, but I just like Sinon&#x27;s API so much better! The code also depends on Underscore/Lodash which is a bit cheap, but what the heck.</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tester</span>(<span class="hljs-params">description,lib,methodtests,I</span>)</span>{<br/>    describe(description,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>        _.each(methodtests,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tests,signature</span>)</span>{<br/>            describe(<span class="hljs-string">&quot;the &quot;</span>+signature+<span class="hljs-string">&quot; method&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                <span class="hljs-keyword">var</span> methodname = signature.split(<span class="hljs-string">&quot;(&quot;</span>)[<span class="hljs-number">0</span>],<br/>                    arglist = signature.split(<span class="hljs-string">&quot;(&quot;</span>)[<span class="hljs-number">1</span>].replace(<span class="hljs-regexp">/\)$/</span>,<span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br/>                _.each(tests,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">test,testdesc</span>)</span>{<br/>                    <span class="hljs-keyword">var</span> givenargs = _.reduce(_.keys(test),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mem,arg</span>)</span>{<br/>                        mem[<span class="hljs-string">&quot;@&quot;</span>+arg] = test[arg];<br/>                        <span class="hljs-keyword">return</span> mem;<br/>                    },{});<br/>                    describe(testdesc,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                        <span class="hljs-keyword">var</span> result, method;<br/>                        beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                            method = lib[methodname];<br/>                            _.each(test.context||{},<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stubdef,stubname</span>)</span>{<br/>                                sinon.stub(lib,stubname,stubdef.method || (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                                    <span class="hljs-keyword">var</span> callcount = <span class="hljs-number">0</span>;<br/>                                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                                        <span class="hljs-keyword">var</span> ret = stubdef.returnseries ? stubdef.returnseries[callcount]<br/>                                            : stubdef.returnsarg !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[stubdef.returnsarg]<br/>                                            : test[stubdef.returns]||stubdef.returns;<br/>                                        callcount++;<br/>                                        <span class="hljs-keyword">return</span> I ? I.fromJS(ret) : ret;<br/>                                    };<br/>                                })());<br/>                            });<br/>                            result = method.apply(lib,arglist.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>)</span>{<br/>                                <span class="hljs-keyword">return</span> I ? I.fromJS(test[param]) : test[param];<br/>                            }));<br/>                        });<br/>                        it(test.description || <span class="hljs-string">&quot;it returns the expected value&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                            expect(result &amp;&amp; result.toJS ? result.toJS() : result).toEqual(test.expected);<br/>                        });<br/>                        _.each(test.context||{},<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stubdef,stubname</span>)</span>{<br/>                            <span class="hljs-keyword">if</span> (stubdef.expectedargs){<br/>                                describe(<span class="hljs-string">&quot;the usage of &quot;</span>+stubname,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                                    <span class="hljs-keyword">var</span> len = stubdef.expectedargs.length;<br/>                                    it(<span class="hljs-string">&quot;called &quot;</span>+stubname+<span class="hljs-string">&quot; &quot;</span>+len+<span class="hljs-string">&quot; time&quot;</span>+(len&gt;<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                                        expect(lib[stubname].callCount).toEqual(len);<br/>                                    });<br/>                                    _.each(stubdef.expectedargs,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args,n</span>)</span>{<br/>                                        describe(<span class="hljs-string">&quot;call #&quot;</span>+n,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                                            it(<span class="hljs-string">&quot;passed &quot;</span>+args.length+<span class="hljs-string">&quot; argument&quot;</span>+(args.length&gt;<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                                                expect((lib[stubname].getCall(n)||{<span class="hljs-attr">args</span>:[]}).args.length).toEqual(args.length);<br/>                                            });<br/>                                            _.each(args,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg,a</span>)</span>{<br/>                                                it(<span class="hljs-string">&quot;used correct value for parameter #&quot;</span>+a,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                                                    <span class="hljs-keyword">var</span> usedargs = (lib[stubname].getCall(n)||{<span class="hljs-attr">args</span>:[]}).args;<br/>                                                    expect((I?I.List(usedargs).toJS():usedargs)[a]).toEqual(givenargs[arg]||arg);<br/>                                                });<br/>                                            });<br/>                                        });<br/>                                    });<br/>                                });<br/>                            }<br/>                        });<br/>                        afterEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                            _.each(test.context||{},<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stubdef,stubname</span>)</span>{<br/>                                lib[stubname].restore();<br/>                            });<br/>                        });<br/>                    });<br/>                });<br/>            });<br/>        });<br/>    });<br/>}</code></pre><h3 id="wrapping-up">Wrapping up</h3><p>Even though the win isn&#x27;t super big, I&#x27;ve found that the threshold for adding to the JSON test definition is lower than that for having to add in another nest of <code>describe</code>, <code>it</code> and <code>equal</code> calls. And, in my book, everything that takes away friction from writing tests is a big win!</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/writing-jasmine-tests-in-a-json-format","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/writing-jasmine-tests-in-a-json-format" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/writing-jasmine-tests-in-a-json-format.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>