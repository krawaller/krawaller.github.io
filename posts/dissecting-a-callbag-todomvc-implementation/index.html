<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Dissecting a Callbag TodoMVC implementation</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/dissecting-a-callbag-todomvc-implementation.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Peeking under the hood of a TodoMVC implementation using only Callbags and Snabbdom</div><hr/><h2>Dissecting a Callbag TodoMVC implementation</h2><p class="taglist">Tags:<!-- --> <a href="/tags/callbags/">callbags</a><a href="/tags/case_study/">case study</a><a href="/tags/snabbdom/">snabbdom</a><a href="/tags/redux/">redux</a><a href="/tags/todomvc/">todomvc</a></p><div class="page-content"><div class="post" data-postid="callbagtodomvc"><h3 id="the-premise">The premise</h3><p>In the previous post we <a href="/posts/callbags-introduction/">familiarised ourselves with Callbags</a>. Now we&#x27;ll look at a more practical example by digging through the codebase of a callbags-based TodoMVC app!</p><h3 id="chopper-view-of-the-app">Chopper view of the app</h3><p>You can find the repo for the app at <a href="https://github.com/krawaller/callbag-todomvc">https://github.com/krawaller/callbag-todomvc</a>, and the live app at <a href="callbag-todomvc.netlify.com">callbag-todomvc.netlify.com</a> (although that isn&#x27;t very sexy as it works exactly like all TodoMVC apps ever (which of course is the point)).</p><p>The code is split into 4 parts; <code>makeActions</code>, <code>makeState</code>, <code>makeView</code> and <code>makeSideEffects</code>. They are chained together like so:</p><p><img src="/static/posts/dissecting-a-callbag-todomvc-implementation/diagrams/callbag-mvi.svg" alt=""/></p><p>If you&#x27;ve ever played with the <a href="https://cycle.js.org/">CycleJS framework</a> you might recognise this as inspired by the <a href="https://cycle.js.org/model-view-intent.html">Model View Intent pattern</a>.</p><p>The chain from the diagram is also visible in the bootstrapping code in the <a href="https://github.com/krawaller/callbag-todomvc/blob/master/src/index.js"><code>index.js</code></a> file of the app:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> actions = makeActions(<span class="hljs-built_in">window</span>, <span class="hljs-built_in">window</span>.document.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>));<br/><span class="hljs-keyword">const</span> state = makeStateStream(actions);<br/><span class="hljs-keyword">const</span> view = makeViewStream(state);<br/><br/>makeSideEffects(<span class="hljs-built_in">window</span>, actions, view);</code></pre><p>We&#x27;ll now walk through the four main parts in order, making some random callbag-related observations along the way!</p><h3 id="actions">Actions</h3><p>The first part of the flow is to hook up event streams and bend those into action streams, which we do in the <a href="https://github.com/krawaller/callbag-todomvc/blob/master/src/actions.js">actions.js</a> file.</p><p>Staltz had already made a <a href="https://github.com/staltz/callbag-from-event">callbag-from-event</a> to create DOM event stream sources, but that didn&#x27;t really work for me - I&#x27;m creating the DOM via a Virtual DOM view stream, so there&#x27;s nothing to initially listen to!</p><p>To mitigate that I made <a href="https://github.com/krawaller/callbag-from-delegated-event">callbag-from-delegated-event</a>, which listens to a root node but filters the events by selector. Much like jQuery&#x27;s <code>.on(evt, selector, handler)</code> syntax.</p><p>As an example of what it looks like, here&#x27;s the definition of the <code>deleteActions</code> stream:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> deleteActions = pipe(<br/>  fromDelegatedEvent(root, <span class="hljs-string">&#x27;.destroy&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>),<br/>  map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> ({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;DELETETODO&#x27;</span>, <span class="hljs-attr">idx</span>: nOfLi(e.target)})),<br/>  share<br/>);</code></pre><p>The <code>nOfLi</code> method is a helper used in many action streams. It uses the target node reference to calculate the index of todo that was clicked:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> nOfLi = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {<br/>  <span class="hljs-keyword">const</span> li = node.closest(<span class="hljs-string">&#x27;li&#x27;</span>);<br/>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(li.parentElement.children).indexOf(li);<br/>};</code></pre><p>Also notice the use of Staltz&#x27; <a href="https://github.com/staltz/callbag-share"><code>share</code></a> operator at the end of <code>deleteActions</code>- in normal stream vocabulary, that turns the stream from <em>cold</em> to <em>hot</em>. Refer to <a href="https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339">Ben Lesh&#x27; blog post</a> for more on that subject, but in essence: If the stream is <code>cold</code> (which is the default), every listener will get its own instance of the stream. Here that would mean different results for <code>noOfLi</code> if you listen after the state maker. We must therefore use <code>share</code> to make it hot!</p><p>The <code>makeActions</code> function will define a whole bunch of action streams in a similar manner. There are nothing else of interest to note, they all look pretty much like <code>deleteActions</code> (but a twist to that story is coming later).</p><p>After all action streams are created, <code>makeActions</code> returns an object containing all of the action strams. It also throws in an <code>allActions</code> stream for good measure, using Staltz&#x27; <a href="https://github.com/staltz/callbag-merge">callbag-merge</a>:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> allActions = merge(initActions, newTodoActions, ... );</code></pre><h3 id="state">State</h3><p>The <code>allActions</code> stream is a good clue to what will come in <a href="https://github.com/krawaller/callbag-todomvc/blob/master/src/state.js">state.js</a>; we&#x27;ll calculate the state by using a <a href="https://redux.js.org/">Redux</a>-like pattern!</p><p><img src="/static/posts/dissecting-a-callbag-todomvc-implementation/diagrams/callbag-redux.svg" alt=""/></p><p>This means that our app state is one single object. Using TypeScript definitions it looks like this:</p><pre><code class="hljs language-javascript">type TodoAppState = {<br/>  <span class="hljs-attr">todos</span>: Todo[]<br/>  <span class="hljs-attr">newName</span>: string <span class="hljs-comment">// content of new todo input</span><br/>  <span class="hljs-attr">editText</span>: string <span class="hljs-comment">// content of edit todo input</span><br/>  <span class="hljs-attr">editing</span>: number | <span class="hljs-literal">null</span> <span class="hljs-comment">// index of todo that we&#x27;re currently editing</span><br/>  <span class="hljs-attr">filter</span>: <span class="hljs-string">&#x27;all&#x27;</span> | <span class="hljs-string">&#x27;completed&#x27;</span> | <span class="hljs-string">&#x27;active&#x27;</span><br/>}</code></pre><p>Here&#x27;s a single <code>Todo</code>:</p><pre><code class="hljs language-javascript">type Todo = {<br/>  <span class="hljs-attr">text</span>: string<br/>  <span class="hljs-attr">done</span>: boolean<br/>}</code></pre><p>There&#x27;s a quote that has been made for every single stream library out there:</p><blockquote><p>Redux is 1 line of [insert stream library name here]</p></blockquote><p>This is true for callbags too, thanks to Staltz&#x27; <a href="https://github.com/staltz/callbag-scan">callbag-scan</a> operator. Here&#x27;s how the <code>makeStateStream</code> function is implemented:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeStateStream</span>(<span class="hljs-params">actions</span>)</span>{<br/>  <span class="hljs-keyword">return</span> pipe(<br/>    actions.allActions,<br/>    scan(augmenter(reducer), initialState),<br/>  );<br/>}</code></pre><p>Here <code>reducer</code> looks <em>exactly</em> like a normal Redux reducer, made up by a big switch statement over <code>action.type</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">currentState, action</span>)</span>{<br/>  <span class="hljs-keyword">switch</span> (action.type) {<br/>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EDITTODO&#x27;</span>: <span class="hljs-keyword">return</span> {...currentState, <span class="hljs-attr">editing</span>: action.idx };<br/>    <span class="hljs-comment">// ....</span><br/>  }<br/>}</code></pre><p>The <code>augmenter</code> is how I chose to handle computed properties - it adds in the <code>remaining</code> count to the state returned by the reducer:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> augmenter = <span class="hljs-function"><span class="hljs-params">reducer</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {<br/>  <span class="hljs-keyword">let</span> newState = reducer(state, action);<br/>  <span class="hljs-keyword">return</span> {<br/>    ...newState,<br/>    <span class="hljs-attr">remaining</span>: newState.todos.filter(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> !t.done).length<br/>  };<br/>};</code></pre><p>The end result is that <code>makeStateStream</code> returns a stream emitting state objects everytime there is a new action.</p><h3 id="view">View</h3><p>The code in <a href="https://github.com/krawaller/callbag-todomvc/blob/master/src/view.js">view.js</a> is rather boring - we simply <code>map</code> the passed-in state stream to a JSX stream!</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeViewStream</span>(<span class="hljs-params">state</span>)</span>{<br/>  <span class="hljs-keyword">return</span> pipe(<br/>    state,<br/>    map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> (<br/>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br/>        { /* full app UI made here */ }<br/>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br/>    ))<br/>  );<br/>}</code></pre><p>I&#x27;m using <a href="https://github.com/Swizz/snabbdom-pragma">Snabbdom-pragma</a> to handle the JSX, which means that all JSX elements are transformed into calls to <code>Snabbdom.createElement</code>.</p><h3 id="side-effects">Side effects</h3><p>Finally, <a href="https://github.com/krawaller/callbag-todomvc/blob/master/src/sideeffects.js">sideeffects.js</a>!</p><p>The primary duty here is to use the view stream to make stuff happen on the screen. For this I&#x27;m using the Snabbdom <code>patch</code> command which has the following syntax:</p><pre><code class="hljs language-javascript">patch(rootNode, JSX); <span class="hljs-comment">// first call</span><br/>patch(previousJSX, newJSX); <span class="hljs-comment">// subsequent calls</span></code></pre><p>In other words I&#x27;ll need access to the new <em>and previous</em> JSX at the same time! For this I built the <a href="https://github.com/krawaller/callbag-with-previous">callbag-with-previous</a> operator:</p><pre><code class="hljs language-javascript">pipe(<br/>  withPrevious(view),<br/>  forEach(<span class="hljs-function">(<span class="hljs-params">[cur,prev,isFirst]</span>) =&gt;</span> {<br/>    patch(isFirst ? <span class="hljs-built_in">window</span>.document.getElementById(<span class="hljs-string">&#x27;renderoutput&#x27;</span>) : prev, cur)<br/>  })<br/>);</code></pre><p>At this point fox-eyed readers might wonder why we passed in the <code>actions</code> too to <code>makeSideEffects</code>:</p><pre><code class="hljs">make<span class="hljs-constructor">SideEffects(<span class="hljs-params">window</span>, <span class="hljs-params">actions</span>, <span class="hljs-params">view</span>)</span>;</code></pre><p>That&#x27;s because we also want to <code>.focus()</code> the various inputs on certain actions. For example, when we edit a todo we want it to gain focus:</p><pre><code class="hljs language-javascript">pipe(<br/>  actions.editActions,<br/>  forEach(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">window</span>.document.querySelector(<span class="hljs-string">&quot;.editing .edit&quot;</span>).focus())<br/>);</code></pre><p>And, this pretty much concludes our tour through the code base!</p><h3 id="losing-control">Losing control</h3><p>I was actually a bit disappointed with how easy it was to define the needed streams. In particular I had hoped for the action streams to provide more of a challenge. Therefore I made a separate version of the app where the contents of the input fields are not part of the app state. Phrased in React lingo; an <em><a href="https://reactjs.org/docs/uncontrolled-components.html">uncontrolled</a></em> approach instead of <em><a href="https://reactjs.org/docs/forms.html#controlled-components">controlled</a></em> one!</p><p>As suspected/hoped, not having the inputs in the state meant having to put more information into the actions, which in turn meant more interesting stream crossing problems. You&#x27;ll find that version in the <a href="https://github.com/krawaller/callbag-todomvc/tree/uncontrolled"><code>uncontrolled</code> branch on Github</a>, but I&#x27;ll walk through a couple of highlights here!</p><p>First example - in the <code>newTodoActions</code> we must now include the current content of the new todo input field. We can do that by transforming the stream of <code>enter</code> key presses into the latest output from the input typing stream, using Staltz&#x27; <a href="https://github.com/staltz/callbag-sample">callbag-sample</a>. However since we want to map to the <em>latest</em> value of that stream I had to make a new operator, <a href="https://github.com/krawaller/callbag-latest">callbag-latest</a>, that in essence turns a listenable source into a pullable one. With these operators we can define <code>newTodoActions</code> like so:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> newTodoActions = pipe(<br/>  fromDelegatedEvent(root, <span class="hljs-string">&#x27;.new-todo&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>),<br/>  filter(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.key === <span class="hljs-string">&#x27;Enter&#x27;</span>),<br/>  sample(latest(newNameTypeStream)),<br/>  filter(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.length),<br/>  map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> ({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NEWTODO&#x27;</span>, <span class="hljs-attr">value</span>: v})),<br/>  share<br/>);</code></pre><p>However, when the input value is not in the state, I need to emit an extra empty string on the <code>newNameTypeStream</code> after each event on <code>newTodoActions</code>. Otherwise you could hit enter again to add the same todo.</p><p>But this means that there is a circular dependency between <code>newNameTypeStream</code> and <code>newTodoActions</code> as both depend on the other! To sort that I had to make <a href="https://github.com/krawaller/callbag-proxy">callbag-proxy</a> for use in <code>newNameTypeStream</code>:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> newTodoActions_proxy = proxy();<br/><span class="hljs-keyword">const</span> newNameTypeStream = pipe(<br/>  fromDelegatedEvent(root, <span class="hljs-string">&#x27;.new-todo&#x27;</span>, <span class="hljs-string">&#x27;change&#x27;</span>),<br/>  map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.value),<br/>  mergeWith(pipe(<br/>    newTodoActions_proxy,<br/>    mapTo(<span class="hljs-string">&#x27;&#x27;</span>)<br/>  ))<br/>);</code></pre><p>Further down, after <code>newTodoActions</code> is defined, we can connect it to the proxy:</p><pre><code class="hljs language-javascript">newTodoActions_proxy.connect(newTodoActions);</code></pre><p>Another stream shenanigan example - There&#x27;s an <code>editSubmissions</code> typing stream that we use to make <code>confirmEditActions</code> (when the edit field has a value) and <code>deleteActions</code> (when the edit field is empty). This stream must now contain <em>both</em> the event target (for calculating which todo it is) <em>and</em> the value (to know the content). For that I had to make the <a href="https://github.com/krawaller/callbag-sample-combine">callbag-sample-combine</a> operator, so that we have access to both:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> editSubmissions = pipe(<br/>  fromDelegatedEvent(root, <span class="hljs-string">&#x27;.edit&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>),<br/>  filter(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.key === <span class="hljs-string">&#x27;Enter&#x27;</span>),<br/>  sampleCombine(latest(editTypeStream)),<br/>  map(<span class="hljs-function">(<span class="hljs-params">[e, v]</span>) =&gt;</span> ({<span class="hljs-attr">value</span>: v, <span class="hljs-attr">target</span>: e.target}))<br/>);</code></pre><p>The uncontrolled version of the app also needs more work in the side effect parts, since we have to manually set the contents of the inputs.</p><h3 id="wrapping-up">Wrapping up</h3><p>I&#x27;ve done my fair share of stream programming using RxJS, xstream, most, etc. But I&#x27;ve never felt as in control as just now with callbags. The fact that there is no core library, that every sink factory and operator is just a function with a predictable signature, makes for a remarkably pure development experience. It becomes more about the streams, instead of the implementation of the streams.</p><p>Of course, having to implement the operators and factories you need yourself is a high price to pay. But since everything is so <em>simple</em>, my counter-argument would be that it didn&#x27;t take me much more energy to do that than it would have for me to wade through the gazillion operators on RxJS to find the one that best suited my needs.</p><p>So where does this all leave us? Will coding with callbags be the way forward for reactive programmers, or will it merely be a pattern that&#x27;ll help with under-the-hood code refactorings for stream libraries?  I&#x27;m honestly not sure.</p><p>But what I do know is that I really enjoyed putting the TodoMVC app together with callbags, and I&#x27;ll definitely try to get some more playtime in with them.</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/dissecting-a-callbag-todomvc-implementation","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/dissecting-a-callbag-todomvc-implementation" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/dissecting-a-callbag-todomvc-implementation.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>