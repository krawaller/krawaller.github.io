<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>How to reduce boilerplate in Redux</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/how-to-reduce-boilerplate-in-redux.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Exploring a pattern that lets us group related logic and reduce boilerplate in Redux apps</div><hr/><h2>How to reduce boilerplate in Redux</h2><p class="taglist">Tags:<!-- --> <a href="/tags/redux/">redux</a><a href="/tags/typescript/">typescript</a><a href="/tags/cyclejs/">cyclejs</a></p><div class="page-content"><div class="post" data-postid="reduxpattern"><h3 id="premise">Premise</h3><p><a href="https://redux.js.org/">Redux</a> is frequently bemoaned for forcing you to write a fair bit of boilerplate. Sometimes that critisism is not fair as the code in question is actually necessary, but definitely Redux app can often feel very verbose.</p><p>In October I attended <a href="http://cycleconf.com/">CycleConf</a>, the yearly conference for the <a href="https://cycle.js.org/">CycleJS</a> framework. There I got to play with <a href="https://cycle.js.org/api/state.html">Cycle State</a>, a new API where each component gets the current state as an input stream, and returns a stream of reducers to calculate the next state.</p><p>CycleJS is of course very (very) different from a Redux-driven app, but I realised that the same pattern can be applied to Redux nonetheless! And doing so means less boilerplate and better grouping of related logic.</p><p>In this post we&#x27;ll explore a TypeScript-driven example, where we&#x27;ll first write &quot;traditional&quot; Redux code, and then refactor it to the pattern in question.</p><p>For brevity&#x27;s sake I&#x27;ll be cutting some corners, so neither logic nor modelling will be optimal with regards to perfomance and convenience.</p><h3 id="the-data-model">The data model</h3><p>Imagine that we have an app with <em>users</em> and <em>posts</em>:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> User = {<br/>  name: <span class="hljs-built_in">string</span>;<br/>  postIds: <span class="hljs-built_in">string</span>[];<br/>};<br/><br/><span class="hljs-keyword">type</span> Post = {<br/>  title: <span class="hljs-built_in">string</span>;<br/>  content: <span class="hljs-built_in">string</span>;<br/>  authorId: <span class="hljs-built_in">string</span>;<br/>};</code></pre><p>They each live in a top-level prop in our <em>app state</em>:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> UserState = { [ID: <span class="hljs-built_in">string</span>]: User };<br/><span class="hljs-keyword">type</span> PostState = { [ID: <span class="hljs-built_in">string</span>]: Post };<br/><br/><span class="hljs-keyword">type</span> AppState = {<br/>  users: UserState;<br/>  posts: PostState;<br/>  <span class="hljs-comment">// ...probably more stuff here too</span><br/>};</code></pre><h3 id="creating-actions">Creating actions</h3><p>We&#x27;ll be using the popular action format where all additional data are collected in a <code>payload</code> prop:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ActionBlueprint&lt;T, P&gt; = {<br/>  <span class="hljs-keyword">type</span>: T;<br/>  payload: P;<br/>};</code></pre><p>For our experiment, let&#x27;s make up two actions - we want to <em>delete posts</em> and <em>add posts</em>!</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> NewPostPayload = {<br/>  title: <span class="hljs-built_in">string</span>;<br/>  content: <span class="hljs-built_in">string</span>;<br/>  authorId: <span class="hljs-built_in">string</span>;<br/>  postId: <span class="hljs-built_in">string</span>;<br/>};<br/><br/><span class="hljs-keyword">type</span> NewPostAction = ActionBlueprint&lt;<span class="hljs-string">&quot;NEW_POST&quot;</span>, NewPostPayload&gt;;<br/><br/><span class="hljs-keyword">type</span> DeletePostPayload = {<br/>  postId: <span class="hljs-built_in">string</span>;<br/>};<br/><br/><span class="hljs-keyword">type</span> DeletePostAction = ActionBlueprint&lt;<span class="hljs-string">&quot;DELETE_POST&quot;</span>, DeletePostPayload&gt;;</code></pre><p>We&#x27;ll also make an <code>AppAction</code> type that&#x27;s simply the union of all existing actions in our app:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> AppAction = NewPostAction | DeletePostAction; <span class="hljs-comment">// ...</span></code></pre><p>Creating a <em>new post action</em> could be done something like this:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> NewPostActionCreator = (<br/>  title: <span class="hljs-built_in">string</span>,<br/>  content: <span class="hljs-built_in">string</span>,<br/>  authorId: <span class="hljs-built_in">string</span>,<br/>  postId: <span class="hljs-built_in">string</span><br/>): <span class="hljs-function"><span class="hljs-params">NewPostAction</span> =&gt;</span> ({<br/>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;NEW_POST&quot;</span>,<br/>  payload: {<br/>    title,<br/>    content,<br/>    authorId,<br/>    postId<br/>  }<br/>});</code></pre><p>And here&#x27;s how we create <em>delete post actions</em>:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> DeletePostActionCreator = (postId: PostId): <span class="hljs-function"><span class="hljs-params">DeletePostAction</span> =&gt;</span> ({<br/>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;DELETE_POST&quot;</span>,<br/>  payload: { postId }<br/>});</code></pre><h3 id="reducer-take-one">Reducer, take one</h3><p>In a traditional Redux app we&#x27;d create a subreducer for <code>appState.posts</code>:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> postReducer = (postState: PostState, action: AppAction): <span class="hljs-function"><span class="hljs-params">PostState</span> =&gt;</span> {<br/>  <span class="hljs-keyword">switch</span> (action.type) {<br/>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;NEW_POST&quot;</span>:<br/>      <span class="hljs-keyword">return</span> {<br/>        ...postState,<br/>        [action.payload.postId]: {<br/>          title: action.payload.title,<br/>          content: action.payload.content,<br/>          authorId: action.payload.authorId<br/>        }<br/>      };<br/>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;DELETE_POST&quot;</span>: {<br/>      <span class="hljs-keyword">const</span> { [action.payload.postId]: DELETE_ME, ...keepUs } = postState;<br/>      <span class="hljs-keyword">return</span> keepUs;<br/>    }<br/>    <span class="hljs-keyword">default</span>:<br/>      <span class="hljs-keyword">return</span> postState;<br/>  }<br/>};</code></pre><p>The subreducer for <code>appState.users</code> also has to deal with both actions, in order to keep the user postlists up to date:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> userReducer = (userState: UserState, action: AppAction): <span class="hljs-function"><span class="hljs-params">UserState</span> =&gt;</span> {<br/>  <span class="hljs-keyword">switch</span> (action.type) {<br/>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;NEW_POST&quot;</span>: {<br/>      <span class="hljs-keyword">const</span> author = userState[action.payload.authorId];<br/>      <span class="hljs-keyword">return</span> {<br/>        ...userState,<br/>        [author.userId]: {<br/>          ...author,<br/>          postIds: author.postIds.concat(action.payload.postId)<br/>        }<br/>      };<br/>    }<br/>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;DELETE_POST&quot;</span>:<br/>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(userState).reduce(<br/>        <span class="hljs-function">(<span class="hljs-params">mem, userId</span>) =&gt;</span> {<br/>          <span class="hljs-keyword">const</span> user = userState[userId];<br/>          <span class="hljs-keyword">return</span> {<br/>            ...mem,<br/>            [userId]: {<br/>              ...user,<br/>              postIds: user.postIds.filter(<span class="hljs-function"><span class="hljs-params">pid</span> =&gt;</span> pid !== action.payload.postId)<br/>            }<br/>          };<br/>        },<br/>        {} <span class="hljs-keyword">as</span> UserState<br/>      );<br/>    <span class="hljs-keyword">default</span>:<br/>      <span class="hljs-keyword">return</span> userState;<br/>  }<br/>};</code></pre><p>The reducer for our entire app state is merely just putting the subreducers together:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Reducer = <span class="hljs-function">(<span class="hljs-params">state: AppState, action: AppAction</span>) =&gt;</span> AppState;<br/><br/><span class="hljs-keyword">const</span> reducer: Reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> ({<br/>  users: userReducer(currentState.users, action),<br/>  posts: postReducer(currentState.posts, action)<br/>});</code></pre><p>Normally you&#x27;d use <code>Redux.combineReducers</code>, but that amounts to the same thing.</p><h3 id="intermission">Intermission</h3><p>So far the traditional approach. What&#x27;s wrong with it?</p><p>Well, some would say we&#x27;ve written a fair bit of boilerplate. I&#x27;m not sure I fully agree, but definitely it feels verbose.</p><p>A worse thing is the shattering of related logic. If you&#x27;re new to the codebase and want to read up on how post deletion works, you have to look in three places:</p><ul><li>the delete action creator</li><li>the user reducer</li><li>the post reducer</li></ul><p>And in reality it is worse - you have to look in the action creator and in ALL subreducers, because you don&#x27;t really know which ones might have interest in the action!</p><h3 id="actions-20">Actions 2.0</h3><p>The pattern we&#x27;re exploring in this post has a very simple solution to this problem - we <em>move all related reducing into the action objects</em>!</p><p>An action, apart from the payload, may therefore also include reducers for whatever state domain it wants to affect! Thus we extend our action type accordingly:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ActionBlueprint&lt;T, P&gt; = {<br/>  <span class="hljs-keyword">type</span>: T;<br/>  payload: P;<br/>  reduceUsers?(userState: UserState, payload: P): UserState;<br/>  reducePosts?(postState: PostState, payload: P): PostState;<br/>};</code></pre><p>Here&#x27;s what the <code>DeletePostActionCreator</code> could look like in this modern take:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> DeletePostActionCreator = (postId: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">DeletePostAction</span> =&gt;</span> ({<br/>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;DELETE_POST&quot;</span>,<br/>  payload: { postId },<br/>  reducePosts(postState, payload) {<br/>    <span class="hljs-keyword">const</span> { [payload.postId]: DELETE_ME, ...keepUs } = postState;<br/>    <span class="hljs-keyword">return</span> keepUs;<br/>  },<br/>  reduceUsers(userState, payload) {<br/>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(userState).reduce(<br/>      <span class="hljs-function">(<span class="hljs-params">mem, userId</span>) =&gt;</span> {<br/>        <span class="hljs-keyword">const</span> user = userState[userId];<br/>        <span class="hljs-keyword">return</span> {<br/>          ...mem,<br/>          [userId]: {<br/>            ...user,<br/>            postIds: user.postIds.filter(<span class="hljs-function"><span class="hljs-params">pid</span> =&gt;</span> pid !== payload.postId)<br/>          }<br/>        };<br/>      },<br/>      {} <span class="hljs-keyword">as</span> UserState<br/>    );<br/>  }<br/>});</code></pre><p>The logic inside the minireducers is what used to live inside individual <code>case</code>:s in the old subreducers.</p><p>And the <code>NewPostActionCreator</code> for completion&#x27;s sake:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> NewPostActionCreator = (<br/>  title: <span class="hljs-built_in">string</span>,<br/>  content: <span class="hljs-built_in">string</span>,<br/>  authorId: <span class="hljs-built_in">string</span>,<br/>  postId: <span class="hljs-built_in">string</span><br/>): <span class="hljs-function"><span class="hljs-params">NewPostAction</span> =&gt;</span> ({<br/>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;NEW_POST&quot;</span>,<br/>  payload: {<br/>    title,<br/>    content,<br/>    authorId,<br/>    postId<br/>  },<br/>  reducePosts(postState, payload) {<br/>    <span class="hljs-keyword">return</span> {<br/>      ...postState,<br/>      [payload.postId]: {<br/>        title: payload.title,<br/>        content: payload.content,<br/>        authorId: payload.authorId<br/>      }<br/>    };<br/>  },<br/>  reduceUsers(userState, payload) {<br/>    <span class="hljs-keyword">const</span> author = userState[payload.authorId];<br/>    <span class="hljs-keyword">return</span> {<br/>      ...userState,<br/>      [author.userId]: {<br/>        ...author,<br/>        postIds: author.postIds.concat(payload.postId)<br/>      }<br/>    };<br/>  }<br/>});</code></pre><p>Note that we don&#x27;t pass in the full action object to the reducers. Why would we? We are inside a specific creator, so we know what type it is!</p><h3 id="reducer-20">Reducer 2.0</h3><p>What about the reducers in this brave new world? Well, first off there are no subreducers anymore. The various cases from their switches instead lives in the individual action creators, as you just saw.</p><p>The main reducer is simply a matter of applying whatever reducers the action in question happen to have:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Reducer = <span class="hljs-function">(<span class="hljs-params"><br/>  state: AppState,<br/>  action: ActionBlueprint&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;<br/></span>) =&gt;</span> AppState;<br/><br/><span class="hljs-keyword">const</span> reducer: Reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> ({<br/>  users: action.reduceUsers<br/>    ? action.reduceUsers(state.users, action.payload)<br/>    : state.users,<br/>  posts: action.reducePosts<br/>    ? action.reducePosts(state.posts, action.payload)<br/>    : state.posts<br/>});</code></pre><h3 id="taking-score">Taking score</h3><p>So, did we reduce the amount of boilerplate? I think so! The string matching with <code>action.type</code> is completely gone, and the Redux-typical switches are nowhere to be seen.</p><p>But the big win in my mind is the colocation of related logic. Each action creator file will contain the full truth about how that particular action affects the state.</p><p>A third, less obvious win is that we get a clearer separation between actions and thunks. Normally it is very common for the former to be created inline in the latter, but now that the actions carry the reducers it is more obvious that they are their own thing.</p><h3 id="actions-30">Actions 3.0</h3><p>But, waitaminue - why are we splitting up the reducing by state domain? Why don&#x27;t we just do everything in a single reducer for the full state in one fell swoop?</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ActionBlueprint&lt;T, P&gt; = {<br/>  <span class="hljs-keyword">type</span>: T;<br/>  payload: P;<br/>  reducer: <span class="hljs-function">(<span class="hljs-params">state: AppState, payload: P</span>) =&gt;</span> AppState;<br/>};</code></pre><p>The <code>NewPostActionCreator</code> can then be streamlined to this...</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> NewPostActionCreator = (<br/>  title: <span class="hljs-built_in">string</span>,<br/>  content: <span class="hljs-built_in">string</span>,<br/>  authorId: UserId,<br/>  postId: PostId<br/>): <span class="hljs-function"><span class="hljs-params">NewPostAction</span> =&gt;</span> ({<br/>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;NEW_POST&quot;</span>,<br/>  payload: {<br/>    postId,<br/>    title,<br/>    content,<br/>    authorId<br/>  },<br/>  reducer(state, payload) {<br/>    <span class="hljs-keyword">const</span> author = state.users[payload.authorId];<br/>    <span class="hljs-keyword">return</span> {<br/>      ...state,<br/>      posts: {<br/>        ...state.posts,<br/>        [payload.postId]: {<br/>          title: payload.title,<br/>          content: payload.content,<br/>          authorId: payload.authorId<br/>        }<br/>      },<br/>      users: {<br/>        ...state.users,<br/>        [author.userId]: {<br/>          ...author,<br/>          posts: author.posts.concat(payload.postId)<br/>        }<br/>      }<br/>    };<br/>  }<br/>});</code></pre><p>...and <code>DeletePostActionCreator</code> becomes very short and sweet:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> DeletePostActionCreator3 = (postId: PostId): <span class="hljs-function"><span class="hljs-params">DeletePostAction</span> =&gt;</span> ({<br/>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;DELETE_POST&quot;</span>,<br/>  payload: { postId },<br/>  reducer(state, payload) {<br/>    <span class="hljs-keyword">const</span> { [payload.postId]: postToDelete, ...postsToKeep } = state.posts;<br/>    <span class="hljs-keyword">const</span> author = state.users[postToDelete.authorId];<br/>    <span class="hljs-keyword">return</span> {<br/>      ...state,<br/>      posts: postsToKeep,<br/>      users: {<br/>        ...state.users,<br/>        [postToDelete.authorId]: {<br/>          ...author,<br/>          posts: author.posts.filter(<span class="hljs-function"><span class="hljs-params">pid</span> =&gt;</span> pid !== payload.postId)<br/>        }<br/>      }<br/>    };<br/>  }<br/>});</code></pre><p>Another cute advantage is that we can now make our action type work for any app by adding the app state type to the generic parameters:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ActionBlueprint&lt;T, P, S&gt; = {<br/>  <span class="hljs-keyword">type</span>: T;<br/>  payload: P;<br/>  reducer: <span class="hljs-function">(<span class="hljs-params">state: S, payload: P</span>) =&gt;</span> S;<br/>};<br/><br/><span class="hljs-keyword">type</span> NewPostAction = ActionBlueprint&lt;<span class="hljs-string">&quot;NEW_POST&quot;</span>, NewPostPayload, AppState&gt;;<br/><span class="hljs-keyword">type</span> DeletePostAction = ActionBlueprint&lt;<br/>  <span class="hljs-string">&quot;DELETE_POST&quot;</span>,<br/>  DeletePostPayload,<br/>  AppState<br/>&gt;;</code></pre><h3 id="reducer-30">Reducer 3.0</h3><p>Now that each action just has one reducer, the &quot;real&quot; reducer becomes even simpler to define:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> reducer: Reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span><br/>  action.reducer ? action.reducer(state, action.payload) : state;</code></pre><p>We still need to check that a reducer exists on the action, since Redux fires its own actions that won&#x27;t have a built-in reducer.</p><h3 id="wrapping-up">Wrapping up</h3><p>I really like how putting the reducing logic inside the action groups all related code together in one place. And you&#x27;ll find that employing this pattern means less cruft and boilerplate.</p><p>The only downside I can see with the pattern we just explored is that it might surprise developers used to the traditional approach. Other than that it is all wins in my book!</p><p>What do <em>you</em> think?</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/how-to-reduce-boilerplate-in-redux","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/how-to-reduce-boilerplate-in-redux" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/how-to-reduce-boilerplate-in-redux.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>