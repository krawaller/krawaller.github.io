<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Implementing a source code view in Storybook</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/implementing-a-source-code-view-in-storybook.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Exploring how to add a source code viewer to a Storybook setup</div><hr/><h2>Implementing a source code view in Storybook</h2><p class="taglist">Tags:<!-- --> <a href="/tags/storybook/">storybook</a><a href="/tags/react/">react</a><a href="/tags/case_study/">case study</a></p><div class="page-content"><div class="post" data-postid="storybooksource"><h3 id="premise">Premise</h3><p>It took me a while to realise, but - <a href="https://storybook.js.org/">Storybook</a> is super awesome! At first I thought it&#x27;s just a tool to display a library of UI components, which it also is, but that&#x27;s not the real value. Storybook lets you test run components in isolation as you build them, and thereby also encourage you to develop them in a decoupled way.</p><p>When teaching <a href="https://edument.se/en/education/courses/query?q=react&amp;category=&amp;location=">Edument&#x27;s React courses</a> I have a collection of small demos to show off React&#x27;s various features. They lived in a homebrewed platform that had some nice feautes, but now I thought - why not serve them in a Storybook?</p><p>So I did, and it was glorious. But, there was one feature from my old platform that Storybook didn&#x27;t have; I couldn&#x27;t show the source code next to the running demo. There is an <a href="https://github.com/storybookjs/storybook/tree/master/addons/storysource">addon to show the source of the story itself</a>, but that&#x27;s not nearly enough - I need to show the code for the component that they import!</p><p>Since the source view was a very appreciated feature, I went ahead and built it into my Storybook. This post walks through how this was done!</p><p><img src="/static/posts/implementing-a-source-code-view-in-storybook/sourceview.gif" alt="The end result"/></p><p>Our Storybook is deployed live at <a href="https://edument-react-examples.netlify.com/">https://edument-react-examples.netlify.com/</a>, and the repo is at <a href="https://github.com/edumentab/react-examples-storybook">https://github.com/edumentab/react-examples-storybook</a>.</p><h3 id="gearing-up">Gearing up</h3><p>Remember that <a href="https://xkcd.com/208/">classic XKCD strip</a> about saving the day with regular expressions?</p><p><img src="/static/posts/implementing-a-source-code-view-in-storybook/xkcd.png" alt="except not PERL"/></p><p>As a curious nerd - and expecially one with an academic background - I frequently find myself deep down rabbit holes with a vague awareness that &quot;ok, this is super neat, but I&#x27;ll never get to use it&quot;.</p><p>One such rabbit hole was exploring how Webpack <a href="https://webpack.js.org/contribute/writing-a-loader/">loaders</a> and <a href="https://webpack.js.org/contribute/writing-a-plugin/">plugins</a> actually work. But, lo and behold, now I found use for them!</p><h3 id="reading-the-source-code">Reading the source code</h3><p>My idea was very simple - hack Storybook&#x27;s webpack setup with a loader that simply <strong>saves the source code to somewhere</strong> as the files are read.</p><p>However, we don&#x27;t want to have <em>all files</em>, for example everything in <code>node_modules</code> should be excluded. So I simply pass in a <code>root</code> source to the loader in the Storybook webpack config...</p><pre><code class="hljs language-javascript">config.module.rules.push({<br/>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$|\.css$/</span>,<br/>  use: [<br/>    {<br/>      <span class="hljs-attr">loader</span>: path.resolve(__dirname, <span class="hljs-string">&quot;sourceCodeUtils/sourceLoader.js&quot;</span>),<br/>      <span class="hljs-attr">options</span>: { <span class="hljs-attr">root</span>: path.resolve(__dirname, <span class="hljs-string">&quot;../src&quot;</span>) }<br/>    }<br/>  ]<br/>});</code></pre><p>...which the loader then uses to know what to remember:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sourceLoader</span>(<span class="hljs-params">source</span>) </span>{<br/>  <span class="hljs-keyword">const</span> opts = <span class="hljs-built_in">this</span>.query || {};<br/>  <span class="hljs-keyword">const</span> { root = <span class="hljs-string">&quot;&quot;</span> } = opts;<br/>  <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">this</span>.resourcePath;<br/>  <span class="hljs-keyword">if</span> (path.match(root)) {<br/>    cache.register(path.substr(root.length).replace(<span class="hljs-regexp">/^\//</span>, <span class="hljs-string">&quot;&quot;</span>), source);<br/>  }<br/>  <span class="hljs-keyword">return</span> source;<br/>}</code></pre><p>Now my cache (which is just a super-simple in-memory object) will contain the source of all files I&#x27;m interested in!</p><h3 id="providing-the-source">Providing the source</h3><p>Now we need to catch the sources saved by the loader! That is done in a <strong>webpack plugin</strong>:</p><pre><code class="hljs language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SourcePlugin</span> </span>{<br/>  apply(compiler) {<br/>    compiler.hooks.emit.tapAsync(<br/>      <span class="hljs-string">&quot;Source Code Plugin&quot;</span>,<br/>      <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> {<br/>        <span class="hljs-keyword">const</span> sources = <span class="hljs-built_in">JSON</span>.stringify(cache.getSources());<br/>        compilation.assets[<span class="hljs-string">&quot;rawSources.json&quot;</span>] = {<br/>          <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> sources,<br/>          <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> sources.length<br/>        };<br/>        callback();<br/>      }<br/>    );<br/>  }<br/>}</code></pre><p>From my cache I&#x27;ll get an object with filenames as keys and source codes as values. I simply take that object and inject it into the assets as <code>rawSources.json</code>.</p><h3 id="adding-the-source-code-tab">Adding the source code tab</h3><p>Next up is adding a &quot;tab&quot; in Storybook to display the source! This is done through the Storybook addon API:</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// Called from the `addons.js` setup file</span><br/>addonAPI.register(<span class="hljs-string">&quot;edumentab/sourcecode&quot;</span>, <span class="hljs-function"><span class="hljs-params">storybookAPI</span> =&gt;</span> {<br/>  <span class="hljs-keyword">const</span> channel = addonAPI.getChannel();<br/><br/>  <span class="hljs-comment">// making the source code available</span><br/>  fetch(<span class="hljs-string">&quot;./rawSources.json&quot;</span>)<br/>    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br/>    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> channel.emit(<span class="hljs-string">&quot;sourceCode/rawSources&quot;</span>, data));<br/><br/>  <span class="hljs-comment">// adding the tab with the sourcecode</span><br/>  addonAPI.add(<span class="hljs-string">&quot;edumentab/sourcecode/panel&quot;</span>, {<br/>    <span class="hljs-attr">type</span>: types.TAB,<br/>    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;source&quot;</span>,<br/>    <span class="hljs-attr">route</span>: <span class="hljs-function">(<span class="hljs-params">{ storyId }</span>) =&gt;</span> <span class="hljs-string">`/sourceCode/<span class="hljs-subst">${storyId}</span>`</span>,<br/>    <span class="hljs-attr">match</span>: <span class="hljs-function">(<span class="hljs-params">{ viewMode }</span>) =&gt;</span> viewMode === <span class="hljs-string">&quot;sourceCode&quot;</span>,<br/>    <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">{ active }</span>) =&gt;</span> {<br/>      <span class="hljs-keyword">return</span> React.createElement(SourcePanel, {<br/>        <span class="hljs-attr">channel</span>: addonAPI.getChannel(),<br/>        storybookAPI,<br/>        active<br/>      });<br/>    }<br/>  });<br/>});</code></pre><p>The <code>SourcePanel</code> component receives the addons <code>channel</code>, from which the sources will be emitted when <code>rawSources.json</code> has been fetched.</p><h3 id="showing-the-source-code">Showing the source code</h3><p>Inside the <code>SourcePanel</code> React component we catch the emission from <code>channel</code>, and let the user select which file to view with a dropdown!</p><p>That means we have two pieces of local state:</p><ul><li>The source files, updated through a subscription on <code>channel</code> created in a <code>useEffect</code> call</li><li>What file is currently selected</li></ul><p>And we render just two things:</p><ul><li>A <code>&lt;select&gt;</code> dropdown to select the file</li><li>A <code>&lt;Highlighter&gt;</code> component to show the current file, using the excellent <a href="https://github.com/conorhastings/react-syntax-highlighter#readme">&#x27;react-syntax-highlighter&#x27;</a> package.</li></ul><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> SourceCodePanel = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {<br/>  <span class="hljs-keyword">const</span> { channel, storybookAPI } = props;<br/>  <span class="hljs-keyword">const</span> [filePath, setFilePath] = useState(<span class="hljs-literal">null</span>);<br/>  <span class="hljs-keyword">const</span> [rawSources, setRawSources] = useState(<span class="hljs-literal">null</span>);<br/>  <span class="hljs-keyword">const</span> handleDropdownChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> setFilePath(e.target.value);<br/>  useEffect(<span class="hljs-function">() =&gt;</span> {<br/>    channel.on(<span class="hljs-string">&quot;sourceCode/rawSources&quot;</span>, setRawSources);<br/>  });<br/>  <span class="hljs-keyword">if</span> (!props.active) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br/>  <span class="hljs-keyword">if</span> (!rawSources) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>...loading...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br/>  <span class="hljs-keyword">return</span> (<br/>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span><br/>      <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleDropdownChange}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{filePath}</span>&gt;</span><br/>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span> ---- Select a file ---<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br/>        {files.map(file =&gt; (<br/>          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{file}</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{file}</span>&gt;</span><br/>            {file}<br/>          <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br/>        ))}<br/>      <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br/>      <span class="hljs-tag">&lt;<span class="hljs-name">Highlighter</span><br/>        <span class="hljs-attr">language</span>=<span class="hljs-string">{filePath.match(/.css$/)</span> ? &quot;<span class="hljs-attr">css</span>&quot; <span class="hljs-attr">:</span> &quot;<span class="hljs-attr">javascript</span>&quot;}<br/>        <span class="hljs-attr">code</span>=<span class="hljs-string">{rawSources[filePath]}</span><br/>        <span class="hljs-attr">onLinkClick</span>=<span class="hljs-string">{handleLinkClick}</span><br/>      /&gt;</span><br/>    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span><br/>  );<br/>};</code></pre><h3 id="switching-source-file-on-story-change">Switching source file on story change</h3><p>This is already rather neat! But, as a user, I expect the source tab to reflect the story that I&#x27;m currently viewing. In other words, we need to change source file whenever a story is changed.</p><p>There is of course a central event for story change available, but that turned out to be insufficient since it doesn&#x27;t contain the name of the source file! Thus we don&#x27;t know which file to switch to.</p><p>My solution was to make a second storybook addon - a decorator that simply emits the story file info upon selection:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> addons, { makeDecorator } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@storybook/addons&quot;</span>;<br/><br/><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> emitSourcePathDecorator = makeDecorator({<br/>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;withSourceInfo&quot;</span>,<br/>  <span class="hljs-attr">parameterName</span>: <span class="hljs-string">&quot;sourceCode&quot;</span>,<br/>  <span class="hljs-attr">wrapper</span>: <span class="hljs-function">(<span class="hljs-params">getStory, context, { parameters }</span>) =&gt;</span> {<br/>    <span class="hljs-keyword">const</span> channel = addons.getChannel();<br/>    channel.emit(<span class="hljs-string">&quot;sourceCode/selectedStory&quot;</span>, context.parameters.fileName);<br/>    <span class="hljs-keyword">return</span> getStory(context);<br/>  }<br/>});</code></pre><p>In our central Storybook <code>config.js</code> we make sure this decorator is applied to every story:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { configure, addDecorator } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@storybook/react&quot;</span>;<br/><span class="hljs-keyword">import</span> { withKnobs } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@storybook/addon-knobs&quot;</span>;<br/><span class="hljs-keyword">import</span> emitSourcePathDecorator <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./sourceCodeUtils/emitSourcePathDecorator&quot;</span>;<br/><br/><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadStories</span>(<span class="hljs-params"></span>) </span>{<br/>  <span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&quot;../src&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.stories\.jsx$/</span>);<br/>  addDecorator(withKnobs);<br/>  addDecorator(emitSourcePathDecorator); <span class="hljs-comment">// &lt;-- our filePath addon</span><br/>  req.keys().forEach(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> req(filename));<br/>}<br/><br/>configure(loadStories, <span class="hljs-built_in">module</span>);</code></pre><p>Finally, in our panel, we add another <code>useEffect</code> that subscribes to the filepath event:</p><pre><code class="hljs language-javascript">useEffect(<span class="hljs-function">() =&gt;</span> {<br/>  channel.on(<span class="hljs-string">&quot;sourceCode/selectedStory&quot;</span>, <span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> {<br/>    <span class="hljs-keyword">if</span> (rawSources) {<br/>      <span class="hljs-keyword">const</span> file = matchPathToSource(path);<br/>      <span class="hljs-keyword">if</span> (file) {<br/>        setFilePath(file);<br/>      }<br/>    }<br/>  });<br/>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> channel.removeListener(<span class="hljs-string">&quot;sourceCode/selectedStory&quot;</span>);<br/>}, [rawSources]);</code></pre><p>The <code>matchPathToSource</code> function is a simple helper that finds the corresponding key in the <code>rawSources</code> object, if any.</p><h3 id="making-import-links-clickable">Making import links clickable</h3><p>A really neat feature that you might have noticed in the GIF up top is that we can also change selected source file by clicking an import statement!</p><p>This was rather easy to add thanks to the excellent hackability of the <code>react-syntax-highlighter</code> package.</p><p>I first made a <code>mapChild</code> function that would receive all nodes in the source code output. The function will identify all import paths and expose their links as a <code>data-link</code> attribute.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> matchRelPath = <span class="hljs-regexp">/^[&quot;&#x27;]\..*[&#x27;&quot;]/</span>;<br/><br/><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapChild</span>(<span class="hljs-params">node, i, row</span>) </span>{<br/>  <span class="hljs-keyword">const</span> extraProps = {};<br/>  <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">3</span>) {<br/>    <span class="hljs-keyword">const</span> content = ((node.children || [])[<span class="hljs-number">0</span>] || {}).value || <span class="hljs-string">&quot;&quot;</span>;<br/>    <span class="hljs-keyword">if</span> (<br/>      <span class="hljs-comment">// text content looks like a relative path</span><br/>      content.match(matchRelPath) &amp;&amp;<br/>      <span class="hljs-comment">// prior node is a space</span><br/>      ((row[i - <span class="hljs-number">1</span>].children || [])[<span class="hljs-number">0</span>] || {}).value === <span class="hljs-string">&quot; &quot;</span> &amp;&amp;<br/>      <span class="hljs-comment">// node 2 steps down is a `from` keyword</span><br/>      ((row[i - <span class="hljs-number">2</span>].children || [])[<span class="hljs-number">0</span>] || {}).value === <span class="hljs-string">&quot;from&quot;</span><br/>    ) {<br/>      <span class="hljs-keyword">return</span> {<br/>        ...node,<br/>        <span class="hljs-attr">properties</span>: {<br/>          ...node.properties,<br/>          <span class="hljs-comment">// expose the link path as an attribute so we can easily find it</span><br/>          <span class="hljs-string">&quot;data-link&quot;</span>: content.replace(<span class="hljs-regexp">/^[&#x27;&quot;]|[&#x27;&quot;]$/g</span>, <span class="hljs-string">&quot;&quot;</span>)<br/>        }<br/>      };<br/>    }<br/>  }<br/>  <span class="hljs-keyword">return</span> node;<br/>}</code></pre><p>We then use that function in a custom renderer that we pass to <code>SyntaxHighlighter</code>:</p><pre><code class="hljs language-javascript">&lt;div className=<span class="hljs-string">&quot;source-code&quot;</span> onClick={handleLinkClick}&gt;<br/>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SyntaxHighlighter</span><br/>    <span class="hljs-attr">style</span>=<span class="hljs-string">{prism}</span><br/>    <span class="hljs-attr">language</span>=<span class="hljs-string">{language}</span><br/>    <span class="hljs-attr">renderer</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">rows</span>, <span class="hljs-attr">stylesheet</span>, <span class="hljs-attr">useInlineStyles</span> }) =&gt;</span> {<br/>      return rows.map((row, i) =&gt; {<br/>        const children = row.children.map(mapChild);<br/>        const link = children.find(<br/>          child =&gt; (child.properties || {})[&quot;data-link&quot;]<br/>        );<br/>        return createElement({<br/>          node: {<br/>            ...row,<br/>            properties: {<br/>              ...row.properties,<br/>              className: [],<br/>              ...(link &amp;&amp; {<br/>                &quot;data-link-row&quot;: link.properties[&quot;data-link&quot;]<br/>              })<br/>            },<br/>            children: row.children.map(mapChild)<br/>          },<br/>          stylesheet,<br/>          useInlineStyles,<br/>          key: `code-segement${i}`<br/>        });<br/>      });<br/>    }}<br/>  &gt;<br/>    {code}<br/>  <span class="hljs-tag">&lt;/<span class="hljs-name">SyntaxHighlighter</span>&gt;</span></span><br/>&lt;/div&gt;</code></pre><p>In the renderer we mark every import statement row with a <code>data-link-row</code> attribute (since we want the entire row to be clickable, not just the string with the path).</p><p>Finally we use that attribute in the <code>handleLinkClick</code> click handler that we wrapped the entire source code with:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> handleLinkClick = useCallback(<br/>  <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {<br/>    <span class="hljs-keyword">const</span> link =<br/>      e.target.getAttribute(<span class="hljs-string">&quot;data-link-row&quot;</span>) ||<br/>      e.target.parentNode.getAttribute(<span class="hljs-string">&quot;data-link-row&quot;</span>);<br/>    <span class="hljs-keyword">if</span> (link) {<br/>      onLinkClick(link);<br/>    }<br/>  },<br/>  [onLinkClick]<br/>);</code></pre><p>The <code>onLinkCLick</code> method here is simply the <code>setFilePath</code> method from our Panel, that has been passed down as a prop.</p><h3 id="including-source-code-for-test-files">Including source code for test files</h3><p>Since all of our React demos have associated unit tests, I wanted to expose those files as well in the source code viewer. But how could I do that? They are not imported by Storybook, which means they never pass through our custom webpack setup!</p><p>The solution turned out to be very simple! First we edit our central <code>config</code> to target both story files and test files:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&quot;../src&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.stories\.jsx$|\.test\.jsx?/</span>);</code></pre><p>Then, make sure the test code isn&#x27;t executed (which would throw errors) by a simple tweak to the return statement in our custom webpack loader:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">return</span> path.match(<span class="hljs-string">&quot;.test.&quot;</span>) ? <span class="hljs-string">&quot;&quot;</span> : source;</code></pre><p>The test files will still be included in the bundle, but as empty strings that have no effect. And the test files are now available for viewing in our source code panel!</p><p><img src="/static/posts/implementing-a-source-code-view-in-storybook/filelist.png" alt="test files too!"/></p><h3 id="showing-both-uncompiled-and-compiled-source">Showing both uncompiled and compiled source</h3><p>Another cheap but cute feature we added was a toggle to show the code both before and after the babel compilation:</p><p><img src="/static/posts/implementing-a-source-code-view-in-storybook/compiled.gif" alt=""/></p><p>We accomplished this simply by including our custom webpack loader two times, once before and once after the babel loader. The second time we pass a <code>compiled: true</code> flag.</p><pre><code class="hljs language-javascript">config.module.rules.push({<br/>  <span class="hljs-comment">// will run before Babel</span><br/>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$|\.css$/</span>,<br/>  use: [<br/>    {<br/>      <span class="hljs-attr">loader</span>: path.resolve(__dirname, <span class="hljs-string">&quot;sourceCodeUtils/webpackLoader.js&quot;</span>),<br/>      <span class="hljs-attr">options</span>: { <span class="hljs-attr">root</span>: path.resolve(__dirname, <span class="hljs-string">&quot;../src&quot;</span>) }<br/>    }<br/>  ]<br/>});<br/>config.module.rules.unshift({<br/>  <span class="hljs-comment">// will run after babel</span><br/>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$|\.css$/</span>,<br/>  use: [<br/>    {<br/>      <span class="hljs-attr">loader</span>: path.resolve(__dirname, <span class="hljs-string">&quot;sourceCodeUtils/webpackLoader.js&quot;</span>),<br/>      <span class="hljs-attr">options</span>: {<br/>        <span class="hljs-attr">root</span>: path.resolve(__dirname, <span class="hljs-string">&quot;../src&quot;</span>),<br/>        <span class="hljs-attr">compiled</span>: <span class="hljs-literal">true</span><br/>      }<br/>    }<br/>  ]<br/>});</code></pre><p>The loader passes the <code>compiled</code> flag on to the cache...</p><pre><code class="hljs language-javascript">cache.register(path.substr(root.length).replace(<span class="hljs-regexp">/^\//</span>, <span class="hljs-string">&quot;&quot;</span>), source, compiled);</code></pre><p>...which now maintains a <code>{ compiled: string, raw: string }</code> object per file path.</p><p>In the source code panel we now track a bool for whether we&#x27;re watching compiled code or not...</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [showCompiled, setShowCompiled] = useState(<span class="hljs-literal">false</span>);</code></pre><p>...which we use to decide what code to pass to the <code>Highlighter</code>:</p><pre><code class="hljs language-javascript">&lt;Highlighter<br/>  code={(rawSources[filePath] || {})[showCompiled ? <span class="hljs-string">&quot;compiled&quot;</span> : <span class="hljs-string">&quot;raw&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>}</code></pre><h3 id="wrapping-up">Wrapping up</h3><p>We&#x27;ve also implemented a history of viewed files so that you can go &quot;back&quot; to the previous file, hot reloading support, and some other minor features, and there are plans for more still.</p><p>But this post has now covered the meat of it, which I hope will prove useful in your own Storybook-hacking adventures!</p><p>Here are the links again:</p><ul><li>Live storybook: <a href="https://edument-react-examples.netlify.com/">https://edument-react-examples.netlify.com/</a></li><li>Git repo: <a href="https://github.com/edumentab/react-examples-storybook">https://github.com/edumentab/react-examples-storybook</a></li></ul></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/implementing-a-source-code-view-in-storybook","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/implementing-a-source-code-view-in-storybook" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/implementing-a-source-code-view-in-storybook.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>