<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>React.js architecture - Flux VS Reflux</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/react-js-architecture-flux-vs-reflux.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Comparing two architectures for React.js apps: Flux, and the Reflux adaption</div><hr/><h2>React.js architecture - Flux VS Reflux</h2><p class="taglist">Tags:<!-- --> <a href="/tags/react/">react</a><a href="/tags/reflux/">reflux</a></p><div class="page-content"><div class="post" data-postid="fluxvsreflux"><p><span style="color:red"><strong>NOTE:</strong> Reflux has gotten even leaner since this post was written. Read the <a href="/posts/reflux-refinement/">follow-up post</a> for more details!</span></p><p><span style="color:red"><strong>NOTE2:</strong> It was fun while it lasted but now I&#x27;m really smitten with <a href="/posts/a-react-redux-example-app/">a new shiny toy - Redux</a>!</span></p><h3 id="flustered-with-flux">Flustered with Flux</h3><p>Recently I&#x27;ve been trying to wrap my brain around using the <a href="http://facebook.github.io/react/docs/flux-overview.html">Flux architecture</a> in a React.js app. I watched the vids, read the blogs, went through <a href="https://egghead.io/series/react-flux-architecture">Egghead&#x27;s excellent tutorial series</a> on the subject, but still didn&#x27;t feel entirely comfortable.</p><p>One of the big wins of React for me was how easy it was to grasp. Understand the difference between properties and state, and BOOM - you&#x27;re done. While with Angular, for example, you have to grokk all of <a href="https://docs.angularjs.org/guide/concepts">this</a> before you can even get started.</p><p>Flux goes a long way to destroy the React advantage, as it comes with a high cognitive price tag much like Angular et al. Here&#x27;s Facebook&#x27;s picture to explain the Flux way:</p><p><img src="/static/posts/react-js-architecture-flux-vs-reflux/img/flux-diagram.png" alt="Flux architecture"/></p><p>Maybe I&#x27;m not the sharpest bulb in the box, but this diagram just doesn&#x27;t speak to me!</p><h3 id="discovering-reflux">Discovering Reflux</h3><p>Looking for options I came across <a href="https://github.com/spoike/refluxjs">Reflux</a> by <a href="http://spoike.ghost.io/">Mikael Brassman a.k.a. Spoike</a>, and was immediately smitten! Reflux takes the Flux approach and streamlines it, making it both easier to work with and easier to grasp.</p><p>The official docs and a quick perusal of the <a href="https://github.com/spoike/refluxjs-todo">Reflux implementation of the TodoMVC app</a> was a great primer, as there really isn&#x27;t much to it. Still I wanted to explore the difference with regards to Flux more concretely!</p><h3 id="flux-vs-reflux">Flux VS Reflux</h3><p>While following along with Egghead&#x27;s tutorial I had just built a small Flux app, so I decided to Refluxify it and see what happened. And it really felt like a big win! The code was shorter, the modules fewer and the couplings easier to track.</p><p>Granted, I don&#x27;t know if Egghead&#x27;s code is the best possible example of Flux architecture, but I feel most of their stuff has a very high level of quality so it should be somewhat representative.</p><p>Either way I thought the switch-out was interesting, and will be walking through it below.</p><h3 id="comparing-dependencies">Comparing dependencies</h3><p>First off, using Reflux means requiring the <code>Reflux</code> library, installable by npm as usual. Flux is pitched as an architecture and not a library, but you need the <a href="https://github.com/facebook/flux/blob/master/src/Dispatcher.js">Dispatcher</a> which you then adapt to your app.</p><p>Thus the net effect is really that in the Reflux version I change out <code>Dispatcher</code> for <code>Reflux</code>.</p><h3 id="comparing-component-calling-actions">Comparing component calling actions</h3><p>For components calling actions, the code is completely identical. Here&#x27;s a button increasing the quoty for an item in the shopping cart.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Increase = React.createClass({<br/>  <span class="hljs-attr">handleClick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br/>    appActions.increaseItem(<span class="hljs-built_in">this</span>.props.index);<br/>  }<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>The Flux and Reflux versions are exactly the same, apart from requiring different versions of <code>appActions</code>. All they do is call the relevant action function, in this case with an index as data.</p><h3 id="comparing-component-listening-to-store-changes">Comparing component listening to store changes</h3><p>Now let&#x27;s compare components who are listening to changes from a store, where there are slight differences between Flux and Reflux. First the Flux version:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> Cart = React.createClass({<br/>  componentDidMount:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{<br/>    appStore.addChangeListener(<span class="hljs-keyword">this</span>._onStuffChange)<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>In <code>componentDidMount</code> we add a change listener, which then takes care of the rest.</p><p>Now for the Reflux version:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> Cart = React.createClass({<br/>  mixins: [Reflux.ListenerMixin],<br/>  componentDidMount: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<br/>    <span class="hljs-keyword">this</span>.listenTo(appStore, <span class="hljs-keyword">this</span>._onStuffChange);<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>The versions are still very similar. The Reflux version uses a <code>ListenerMixin</code> which supplies a <code>.listenTo</code> method, which is called in <code>componentDidMount</code> with the store as an argument. Other than that the code is the same as for the Flux version.</p><h3 id="comparing-stores">Comparing stores</h3><p>Now for the interesting stuff! Below is the code for the Flux store.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> appStore = merge(EventEmitter.prototype, {<br/>  <span class="hljs-attr">emitChange</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>    <span class="hljs-built_in">this</span>.emit(CHANGE_EVENT)<br/>  },<br/>  <span class="hljs-attr">addChangeListener</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)</span>{<br/>    <span class="hljs-comment">//this.on(CHANGE_EVENT, callback)</span><br/>    <span class="hljs-built_in">this</span>.addListener(CHANGE_EVENT, callback)<br/>  },<br/>  <span class="hljs-attr">removeChangeListener</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)</span>{<br/>    <span class="hljs-built_in">this</span>.removeListener(CHANGE_EVENT, callback)<br/>  },<br/>  <span class="hljs-attr">dispatcherIndex</span>:AppDispatcher.register(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">payload</span>)</span>{<br/>    <span class="hljs-keyword">var</span> action = payload.action;<br/>    <span class="hljs-keyword">switch</span>(action.actionType){<br/>      <span class="hljs-keyword">case</span> AppConstants.ADD_ITEM:<br/>        _addItem(payload.action.item);<br/>        <span class="hljs-keyword">break</span>;<br/>      <span class="hljs-keyword">case</span> AppConstants.REMOVE_ITEM:<br/>        _removeItem(payload.action.index);<br/>        <span class="hljs-keyword">break</span>;<br/>      <span class="hljs-keyword">case</span> AppConstants.INCREASE_ITEM:<br/>        _increaseItem(payload.action.index);<br/>        <span class="hljs-keyword">break</span>;<br/>      <span class="hljs-keyword">case</span> AppConstants.DECREASE_ITEM:<br/>        _decreaseItem(payload.action.index);<br/>        <span class="hljs-keyword">break</span>;<br/>    }<br/>    appStore.emitChange();<br/>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br/>  }),<br/>  <span class="hljs-comment">// rest redacted</span><br/>);</code></pre><p>And here&#x27;s the corresponding Reflux store:</p><pre><code class="hljs language-javascript">Reflux.createStore({<br/>  <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.addItem, _addItem);<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.removeItem, _removeItem);<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.increaseItem, _increaseItem);<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.decreaseItem, _decreaseItem);<br/>  }<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>The simpler structure of Reflux is beginning to shine!</p><h3 id="comparing-actions">Comparing actions</h3><p>The actions in the Flux version are rather verbose:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> appActions = {<br/>  <span class="hljs-attr">addItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{<br/>    AppDispatcher.handleViewAction({<br/>      <span class="hljs-attr">actionType</span>: AppConstants.ADD_ITEM,<br/>      <span class="hljs-attr">item</span>: item<br/>    });<br/>  },<br/>  <span class="hljs-attr">removeItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{<br/>    AppDispatcher.handleViewAction({<br/>      <span class="hljs-attr">actionType</span>: AppConstants.REMOVE_ITEM,<br/>      <span class="hljs-attr">index</span>: index<br/>    });<br/>  },<br/>  <span class="hljs-attr">decreaseItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{<br/>    AppDispatcher.handleViewAction({<br/>      <span class="hljs-attr">actionType</span>: AppConstants.DECREASE_ITEM,<br/>      <span class="hljs-attr">index</span>: index<br/>    });<br/>  },<br/>  <span class="hljs-attr">increaseItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{<br/>    AppDispatcher.handleViewAction({<br/>      <span class="hljs-attr">actionType</span>: AppConstants.INCREASE_ITEM,<br/>      <span class="hljs-attr">index</span>: index<br/>    });<br/>  }<br/>};</code></pre><p>While in Reflux they&#x27;re absolutely not:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> appActions = Reflux.createActions([<br/>  <span class="hljs-string">&quot;addItem&quot;</span>,<br/>  <span class="hljs-string">&quot;removeItem&quot;</span>,<br/>  <span class="hljs-string">&quot;decreaseItem&quot;</span>,<br/>  <span class="hljs-string">&quot;increaseItem&quot;</span><br/>]);</code></pre><h3 id="comparing-appdispatchers">Comparing AppDispatchers</h3><p>Fist the Flux version:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> AppDispatcher = merge(Dispatcher.prototype, {<br/>  <span class="hljs-attr">handleViewAction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>) </span>{<br/>    <span class="hljs-built_in">this</span>.dispatch({<br/>      <span class="hljs-attr">source</span>: <span class="hljs-string">&quot;VIEW_ACTION&quot;</span>,<br/>      <span class="hljs-attr">action</span>: action<br/>    });<br/>  }<br/>});</code></pre><p>And now the Reflux version:</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// Unicorns and rainbows!</span></code></pre><p>That&#x27;s right - Reflux does away entirely with the concept of an app-specific dispatcher.</p><h3 id="wrapping-up">Wrapping up</h3><p>Probably Flux proponents can find many things being not entirely fair in this comparison, but for me, changing to Reflux made me breathe easier. The code is sleek, and I have a firm grasp of how the parts are wired. Components listen to stores and call actions. Stores listen to actions and toot when they&#x27;re updated. Simple as that!</p><img src="/static/posts/react-js-architecture-flux-vs-reflux/img/reflux-flow.jpg" style="margin-left:4em;max-height:300px"/><p>I&#x27;ve glanced at some other Flux-inspired libraries, of which there are many. So far Reflux seems to be the most solid option, and I&#x27;m excited to follow along in its continued development!</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/react-js-architecture-flux-vs-reflux","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/react-js-architecture-flux-vs-reflux" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/react-js-architecture-flux-vs-reflux.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>