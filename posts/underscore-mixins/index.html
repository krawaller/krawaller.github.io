<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Underscore mixins</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/underscore-mixins.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Some methods I usually mix into Underscore</div><hr/><h2>Underscore mixins</h2><p class="taglist">Tags:<!-- --> <a href="/tags/underscore/">Underscore</a></p><div class="page-content"><div class="post" data-postid="underscoremixins"><p>Here are some methods I usually mix into Underscore:</p><h3 id="ensurearrayvalemptyel"><code>ensureArray(val,emptyel)</code></h3><p>This method always gives you back an array. There are four different scenarios:</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// when passed an array, we get that array back:</span><br/>_.ensureArray([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]); <span class="hljs-comment">// =&gt; [1,2,3]</span><br/><br/><span class="hljs-comment">// when passed a truthy value that isn&#x27;t an array,</span><br/><span class="hljs-comment">// you get that value wrapped in an array:</span><br/>_.ensureArray(<span class="hljs-number">1</span>); <span class="hljs-comment">// =&gt; [1]</span><br/><br/><span class="hljs-comment">// when passed a falsy value, we get an empty array:</span><br/>_.ensureArray(undefvar); <span class="hljs-comment">// =&gt; []</span><br/><br/><span class="hljs-comment">// when passed a falsy value and the optional `emptyel` parameter,</span><br/><span class="hljs-comment">// we get that parameter in an array:</span><br/>_.ensureArray(undefvar,x); <span class="hljs-comment">// =&gt; [x]</span></code></pre><p>The point of the method is of course to safely use an API that expects an array when you&#x27;re not sure exactly what you&#x27;ve got. Here&#x27;s the source code:</p><pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o,e)</span>{ <span class="hljs-title">return</span> <span class="hljs-title">o</span> ? <span class="hljs-params">[]</span>.<span class="hljs-title">concat</span><span class="hljs-params">(o)</span> : <span class="hljs-title">e</span> ? <span class="hljs-params">[e]</span> : <span class="hljs-params">[]</span>;}</span><br/></code></pre><p>A <a href="https://github.com/jashkenas/underscore/pull/816">pull request</a> to add this into Underscore proper was shot down by Ashkenas for being too special case and because there are other object types too with the same problem. I agree with the first sentiment but not the second; We can easily ensure booleans (<code>!!x</code>), strings (<code>&quot;&quot;+x</code>) and numbers (<code>+x</code>), but arrays alone require logic! Converting to objects will always be domain-specific so they don&#x27;t really play into this discussion.</p><h3 id="mapobjobjiteratorcontext"><code>mapObj(obj,iterator,context)</code></h3><p>The <code>mapObj</code> follows the filosophy of <code>map</code>, but returns an object instead of an array. Here&#x27;s a silly example:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> obj = {a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>}, <span class="hljs-function"><span class="hljs-keyword">fn</span> = <span class="hljs-title">function</span>(<span class="hljs-params">i</span>)</span>{<span class="hljs-keyword">return</span> i*<span class="hljs-number">3</span>;};<br/><br/>mapObj(obj,<span class="hljs-function"><span class="hljs-keyword">fn</span>)</span>; <span class="hljs-comment">// =&gt; {a:3,b:6}</span></code></pre><p>There&#x27;s been lots of pull requests and issues asking for this feature, but as it can be nicely composed and is considered to be a rare use case it has been denied. I however find myself very frequently needing to map objects, so being able to do that in a simple function call cleans up the codebase nicely. Here&#x27;s the source:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj,iterator,context</span>)</span>{<br/>    <span class="hljs-keyword">var</span> keys = _.keys(obj);<br/>    <span class="hljs-keyword">return</span> _.reduce(_.map(obj,iterator,context),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">memo,val,i</span>)</span>{<br/>        <span class="hljs-keyword">return</span> _.extend(_.object([keys[i]],[val]),memo);<br/>    },{});<br/>}</code></pre><p>If you&#x27;re using Lo-Dash then there is already a function called <a href="http://lodash.com/docs#mapValues"><code>mapValues</code></a> that does all of the above and more!</p><h3 id="extendpropobjpropnamesourcesource"><code>extendProp(obj,propname,source,source,...)</code></h3><p>This is a utility method for exending an object which is the property of another object, which works even if the property doesn&#x27;t exist. Doing this:</p><pre><code class="hljs language-javascript">_.extend(obj[propname],source,source,...);</code></pre><p>...would fail if the <code>propname</code> property is undefined.Here&#x27;s the source:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>    <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], propname = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>], sources = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);<br/>    obj[propname] = _.extend.apply(<span class="hljs-built_in">this</span>,[obj[propname]||{}].concat(sources));<br/>    <span class="hljs-keyword">return</span> obj;<br/>}<br/></code></pre><p>As the parent object is returned we can chain more operations on the target object.</p><h3 id="combinearrayarray"><code>combine(array,array,...)</code></h3><p>This method creates an array with all possible combinations from the given arrays, taking one element from each per combination. Here&#x27;s an example:</p><pre><code class="hljs language-javascript">_.combine([1,2,3],[&quot;a&quot;,&quot;b&quot;],[‚Äùfoo&quot;,&quot;bar&quot;,&quot;baz&quot;]);<br/>// =&gt; [ [1,&quot;a&quot;,&quot;foo&quot;],[1,&quot;a&quot;,&quot;bar&quot;],[1,&quot;a&quot;,&quot;baz&quot;],[1,&quot;b&quot;,&quot;foo&quot;],[1,&quot;b&quot;,&quot;bar&quot;],[1,&quot;b&quot;,&quot;baz&quot;],[2,&quot;a&quot;,&quot;foo&quot;],[2,&quot;a&quot;,&quot;bar&quot;],[2,&quot;a&quot;,&quot;baz&quot;],[2,&quot;b&quot;,&quot;foo&quot;],[2,&quot;b&quot;,&quot;bar&quot;],[2,&quot;b&quot;,&quot;baz&quot;]]</code></pre><p>The number of combinations will equal the product of the lengths of the given arrays, and each combination will contain as many elements as the number of arrays you fed into <code>combine</code>.</p><p>This isn&#x27;t something you&#x27;ll need every day (which is why it was <a href="https://github.com/jashkenas/underscore/pull/1788">shot down from Underscore</a>), but when you do need it, doing it manually is very verbose so a helper really cleans up the code (which is why I <a href="https://github.com/documentcloud/underscore-contrib/pull/168">tried to sell it to Underscore-contrib</a> instead).</p><p>Here&#x27;s the source code:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>    <span class="hljs-keyword">return</span> _.reduce(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret,newarr</span>)</span>{<br/>        <span class="hljs-keyword">return</span> _.reduce(ret,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">memo,oldi</span>)</span>{<br/>            <span class="hljs-keyword">return</span> memo.concat(_.map(newarr,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newi</span>)</span>{<br/>                <span class="hljs-keyword">return</span> oldi.concat(newi);<br/>            }));<br/>        },[]);<br/>    },_.map(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>{<span class="hljs-keyword">return</span> [i];}));<br/>}</code></pre><h3 id="mixing-it-in">Mixing it in</h3><p>The methods are added to underscore through the <code>mixin</code> method:</p><pre><code class="hljs">_.mixin({<br/>    <span class="hljs-attr">ensureArray</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o,e</span>)</span>{ <span class="hljs-keyword">return</span> o ? [].concat(o) : e ? [e] : [];},<br/>    <span class="hljs-attr">mapObj</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj,iterator,context</span>)</span>{<br/>        <span class="hljs-keyword">var</span> keys = _.keys(obj);<br/>        <span class="hljs-keyword">return</span> _.reduce(_.map(obj,iterator,context),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">memo,val,i</span>)</span>{<br/>            <span class="hljs-keyword">return</span> _.extend(_.object([keys[i]],[val]),memo);<br/>        },{});<br/>    },<br/>    <span class="hljs-attr">extendProp</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>        <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], propname = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>], sources = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);<br/>        obj[propname] = _.extend.apply(<span class="hljs-built_in">this</span>,[obj[propname]||{}].concat(sources));<br/>        <span class="hljs-keyword">return</span> obj;<br/>    },<br/>    <span class="hljs-attr">combine</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>        <span class="hljs-keyword">return</span> _.reduce(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret,newarr</span>)</span>{<br/>            <span class="hljs-keyword">return</span> _.reduce(ret,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">memo,oldi</span>)</span>{<br/>                <span class="hljs-keyword">return</span> memo.concat(_.map(newarr,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newi</span>)</span>{<br/>                    <span class="hljs-keyword">return</span> oldi.concat(newi);<br/>                }));<br/>            },[]);<br/>        },_.map(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>{<span class="hljs-keyword">return</span> [i];}));<br/>    }<br/>});</code></pre></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/underscore-mixins","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/underscore-mixins" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/underscore-mixins.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>