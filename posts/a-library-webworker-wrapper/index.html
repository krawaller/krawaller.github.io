<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>A library webworker wrapper</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/a-library-webworker-wrapper.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Presenting a tool to create an asynchronous webworker version of a library</div><hr/><h2>A library webworker wrapper</h2><p class="taglist">Tags:<!-- --> <a href="/tags/webworker/">webworker</a></p><div class="page-content"><div class="post" data-postid="webworkers"><h3 id="the-premise">The premise</h3><p>Imagine you have a library, consisting of an <strong>object with a bunch of methods</strong>. Some or all of those are heavy, and will lock up the thread for a while.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> myHeavyLib = {<br/>  <span class="hljs-attr">aHeavyMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>{<br/>    <span class="hljs-comment">// extremely heavy computing left out here</span><br/>    <span class="hljs-keyword">return</span> arg1 + arg2;<br/>  },<br/>  <span class="hljs-attr">anotherHeavyMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>{<br/>    <span class="hljs-comment">// extremely heavy computing left out here</span><br/>    <span class="hljs-keyword">return</span> arg1 + arg2;<br/>  }<br/>  <span class="hljs-comment">// etc</span><br/>};</code></pre><p>If we&#x27;re using this library in a web app, this won&#x27;t be a nice user experience. We should fix that by <strong>delegating the heavy lifting to a Web worker</strong>.</p><p>This situation happened to me very recently, and instead of just webworkerifying my library, I generalised prematurely and made a <strong>tool to webworkerify any library</strong>!</p><h3 id="meet-workerwrapper">Meet WorkerWrapper</h3><p>I made a command line tool I call WorkerWrapper. Feed it a library...</p><p><img src="/static/posts/a-library-webworker-wrapper/diagrams/workerwrapper.svg" alt=""/></p><p>...and it will <strong>generate two files</strong>. First off an <strong>async version</strong> of the library. This is a very small file that gives you an object containing the same method names as the library, but they now return promises that resolves when a webworker gets the result from the real method.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> asyncVersion = {<br/>  <span class="hljs-attr">aHeavyMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>{<br/>    <span class="hljs-comment">// wrapping magic left out here</span><br/>    <span class="hljs-keyword">return</span> promise;<br/>  },<br/>  <span class="hljs-attr">anotherHeavyMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>{<br/>    <span class="hljs-comment">// wrapping magic left out here</span><br/>    <span class="hljs-keyword">return</span> promise;<br/>  }<br/>  <span class="hljs-comment">// etc</span><br/>};</code></pre><p>The async version then spawns web workers from the <strong>worker version</strong>, which is really just the library with a web worker facade on top.</p><h3 id="usage">Usage</h3><p>Say our heavy lib is at <code>lib/heavylib.js</code>.</p><p>We would then <strong>include WorkerWrapper</strong> as a dependency in <code>package.json</code>, and add a <strong>script using the <code>workerwrap</code> command</strong> that WorkerWrapper exposes:</p><pre><code class="hljs">{<br/>  <span class="hljs-attr">&quot;dependencies&quot;</span>: {<br/>    <span class="hljs-attr">&quot;workerwrapper&quot;</span>: <span class="hljs-string">&quot;github:krawaller/workerwrapper&quot;</span><br/>  },<br/>  <span class="hljs-attr">&quot;scripts&quot;</span>: {<br/>    <span class="hljs-attr">&quot;wrap&quot;</span>: <span class="hljs-string">&quot;workerwrap lib/heavylib.js&quot;</span><br/>  }<br/>}</code></pre><p>The command just takes one parameter, namely the relative path to the library to be wrapped.</p><p>Now <code>heavylib_worker.js</code> and <code>heavylib_async.js</code> will be created next to <code>heavylib.js</code>. I consume <code>heavylib_async.js</code> in my app.</p><p>However! In order to allow setup with the worker file, <code>heavylib_async.js</code> doesn&#x27;t export the wrapped library directly, but a function!</p><pre><code class="hljs"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pathToWorkerFile, numberOfWorkers</span>)</span>{<br/><br/>    <span class="hljs-comment">// ...wrapping magic here...</span><br/><br/>    <span class="hljs-keyword">return</span> wrappedLib;<br/>}</code></pre><p>You call this function with a relative path to where you&#x27;ve placed the worker file, as well as the number of parallel webworkers you want spun up.</p><h3 id="see-it-in-action">See it in action</h3><p>In the live app below I&#x27;ve wrapped this silly library:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> heavyLib = {<br/>  <span class="hljs-attr">aHeavyMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1,arg2</span>)</span>{<br/>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;aHeavyMethod called in lib&quot;</span>);<br/>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> a=<span class="hljs-number">0</span>; a&lt;<span class="hljs-number">70000</span>; a++){<br/>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> b=<span class="hljs-number">0</span>; b&lt;<span class="hljs-number">70000</span>; b++){<br/>      }<br/>    }<br/>    <span class="hljs-keyword">return</span> arg1 + arg2;<br/>  }<br/>}</code></pre><p>On my machine the method takes around 2 seconds. Experiment with hitting the single-worker and multi-worker versions multiple times in quick succession, and you&#x27;ll see the benefits of parallel workers!</p><iframe src="https://blog.krawaller.se/workerdemo/index.html" style="height:500px;width:100%"></iframe><p>You can run the demo in a standalone tab <a href="https://blog.krawaller.se/workerdemo/">here</a>, and the demo source code is <a href="https://github.com/krawaller/workerdemo">here</a>.</p><h3 id="under-the-hood-of-the-wrapper">Under the hood of the wrapper</h3><p>You can peruse the full source code for the tool <a href="https://github.com/krawaller/workerwrapper">here</a>, but in short, the script doing the wrapping works with <strong>two template files</strong>.</p><p>Here&#x27;s the one for the async version:</p><pre><code class="hljs"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pathToLib, nbrOfWorkers</span>)</span>{<br/><br/>  nbrOfWorkers = nbrOfWorkers || <span class="hljs-number">1</span>;<br/><br/>  <span class="hljs-keyword">var</span> workerListeners = {};<br/>  <span class="hljs-keyword">var</span> freeWorkers = [];<br/>  <span class="hljs-keyword">var</span> busyWorkers = [];<br/>  <span class="hljs-keyword">var</span> nextCallId = <span class="hljs-number">0</span>;<br/><br/>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">freeUpWorker</span>(<span class="hljs-params">worker</span>)</span>{<br/>    busyWorkers = busyWorkers.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>)</span>{ <span class="hljs-keyword">return</span> w !== worker; });<br/>    freeWorkers.push(worker);<br/>  }<br/><br/>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestWorker</span>(<span class="hljs-params"></span>)</span>{<br/>    <span class="hljs-keyword">var</span> worker = (freeWorkers.length ? freeWorkers : busyWorkers).shift();<br/>    busyWorkers.push(worker);<br/>    <span class="hljs-keyword">return</span> worker;<br/>  }<br/><br/>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workerMessageHandler</span>(<span class="hljs-params">e</span>)</span>{<br/>    <span class="hljs-keyword">var</span> resultid = e.data[<span class="hljs-number">0</span>];<br/>    <span class="hljs-keyword">var</span> result = e.data[<span class="hljs-number">1</span>];<br/>    workerListeners[resultid](result);<br/>    <span class="hljs-keyword">delete</span> workerListeners[resultid];<br/>    freeUpWorker(<span class="hljs-built_in">this</span>);<br/>  }<br/><br/>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">libMethod</span>(<span class="hljs-params">method</span>)</span>{<br/>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>).slice(<span class="hljs-number">1</span>);<br/>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>{<br/>      <span class="hljs-keyword">var</span> callid = ++nextCallId;<br/>      <span class="hljs-keyword">var</span> worker = requestWorker();<br/>      worker.postMessage([method,callid,args]);<br/>      workerListeners[callid] = resolve;<br/>    });<br/>  }<br/><br/>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;nbrOfWorkers; i++){<br/>    <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> Worker(pathToLib);<br/>    worker.onmessage = workerMessageHandler;<br/>    freeUpWorker(worker);<br/>  }<br/><br/>  <span class="hljs-keyword">return</span> LIB_METHODS.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mem,method</span>)</span>{<br/>    mem[method] = libMethod.bind(<span class="hljs-literal">null</span>,method);<br/>    <span class="hljs-keyword">return</span> mem;<br/>  },{});<br/><br/>};</code></pre><p>Notice the <code>LIB_METHODS</code> at the bottom, which the build script replaces with an array of the methods in the library to be wrapped:</p><pre><code class="hljs">fs.writeFileSync(<br/>  pathToLibDir + <span class="hljs-string">&#x27;/&#x27;</span>+libName+<span class="hljs-string">&#x27;_async.js&#x27;</span>,<br/>  wrapperTemplate.replace(<span class="hljs-string">&#x27;LIB_METHODS&#x27;</span>, JSON.stringify(Object.keys(<span class="hljs-class"><span class="hljs-keyword">lib</span>)))</span><br/>);</code></pre><p>The template to the worker file is much simpler:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> lib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;PATH_TO_LIB&#x27;</span>);<br/><br/>onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<br/>  <span class="hljs-keyword">var</span> method = e.data[<span class="hljs-number">0</span>];<br/>  <span class="hljs-keyword">var</span> callid = e.data[<span class="hljs-number">1</span>];<br/>  <span class="hljs-keyword">var</span> args = e.data[<span class="hljs-number">2</span>];<br/>  <span class="hljs-keyword">var</span> result = lib[method].apply(lib,args);<br/>  postMessage([callid,result]);<br/>}</code></pre><p>The script uses webpack to bundle the library into the template.</p><pre><code class="hljs">fs.writeFileSync(pathToTempFile, workerTemplate.<span class="hljs-meta">replace</span>(<span class="hljs-string">&#x27;PATH_TO_LIB&#x27;</span>, pathToLib));<br/><br/>var compiler = webpack({<br/>  entry: pathToTempFile,<br/>  <span class="hljs-meta">output</span>: {<br/>    path: pathToLibDir,<br/>    <span class="hljs-meta">filename</span>: <span class="hljs-meta">libName</span> + <span class="hljs-string">&#x27;_worker.js&#x27;</span><br/>  },<br/>  resolve: {<br/>    extensions: [<span class="hljs-string">&quot;.js&quot;</span>]<br/>  }<br/>});<br/><br/>compiler.r<span class="hljs-meta">un(</span>functi<span class="hljs-meta">on(</span>err,stats){<br/>  var <span class="hljs-meta">message</span> = stats.toString(<span class="hljs-string">&quot;errors-only&quot;</span>) || <span class="hljs-string">&#x27;Webworker file created at &#x27;</span>+pathToLibDir+<span class="hljs-string">&#x27;/&#x27;</span>+<span class="hljs-meta">libName</span> + <span class="hljs-string">&#x27;_worker.js&#x27;</span>;<br/>  console<span class="hljs-meta">.log(</span><span class="hljs-meta">message</span>);<br/>  fs.unlinkSync(pathToTempFile);<br/>});</code></pre><p>Refer to the <a href="https://github.com/krawaller/workerwrapper">source code</a> for the full truth.</p><h3 id="wrapping-up">Wrapping up</h3><p>Pun very much intented.</p><p>Is a stand-alone tool to do this really needed? Likely not, but I had fun, and it felt good to be able to remove all the wrapping code from the repo of the library I was working on.</p><p>Which is also the library I should immediately go back to work on, if I want to keep my job.</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/a-library-webworker-wrapper","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/a-library-webworker-wrapper" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/a-library-webworker-wrapper.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>