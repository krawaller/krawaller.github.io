<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Callbags introduction</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/callbags-introduction.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Wrapping our brains around the Callbags specification for streams represented by functions</div><hr/><h2>Callbags introduction</h2><p class="taglist">Tags:<!-- --> <a href="/tags/callbags/">callbags</a></p><div class="page-content"><div class="post" data-postid="callbagintro"><h3 id="the-premise">The premise</h3><p>In this post we&#x27;ll explore <strong>Callbags</strong> - a new spec by André Staltz for streams. You&#x27;re assumed to be familiar with streams in general. If you&#x27;re not, check out André&#x27;s excellent <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">guide to reactive programming</a>.</p><p>After familiarising ourselves with callbags in this post, we&#x27;ll use our newfound knowledge to <a href="/posts/dissecting-a-callbag-todomvc-implementation/">explore a Callbags TodoMVC example</a> in the next post.</p><h3 id="callbags">Callbags</h3><p>As mentioned above, <strong>Callbags</strong> are a spec for streams. It is brilliant in it&#x27;s simplicity, and allows for streams to be represented by just a simple function!</p><p>A function is a callbag if it has the signature <code>(t: 0 | 1 | 2, d: any) =&gt; void</code> and behaves thusly when called:</p><pre><code class="hljs language-javascript">callbag(<span class="hljs-number">0</span>, talkback); <span class="hljs-comment">// If this is the initiating call: Hey, I am a listener</span><br/>                      <span class="hljs-comment">// and I want data from you! Please call the talkback (which is</span><br/>                      <span class="hljs-comment">// a callbag representing me) with an acknowledgement and any</span><br/>                      <span class="hljs-comment">// subsequent communication.</span><br/><br/>callbag(<span class="hljs-number">0</span>, talkback); <span class="hljs-comment">// If it this is a reply: Hello, I am a source, I have</span><br/>                      <span class="hljs-comment">// registered your subscription! I will now start pushing data</span><br/>                      <span class="hljs-comment">// to you if I am a listenable source, or I will await requests </span><br/>                      <span class="hljs-comment">// from you if I am a pullable source. Talk to the talkback</span><br/>                      <span class="hljs-comment">// if you want to terminate our relationship or request pullable</span><br/>                      <span class="hljs-comment">// data.</span><br/><br/>callbag(<span class="hljs-number">1</span>);           <span class="hljs-comment">// I assume you are a pullable source! Please send data!</span><br/><br/>callbag(<span class="hljs-number">1</span>, stuff);    <span class="hljs-comment">// Here you go listener, here is some data!</span><br/><br/>callbag(<span class="hljs-number">2</span>);           <span class="hljs-comment">// I don&#x27;t want to be friends with you anymore! Please don&#x27;t</span><br/>                      <span class="hljs-comment">// talk to me again! Also I won&#x27;t talk to you again ever!</span><br/><br/>callbag(<span class="hljs-number">2</span>, stuff);    <span class="hljs-comment">// I know you wanted data but something wen&#x27;t wrong! I won&#x27;t</span><br/>                      <span class="hljs-comment">// send you more data ever!</span></code></pre><p>In other words, the first <code>t</code> parameter has the following meanings:</p><ul><li><code>0</code>: creating a relationship.</li><li><code>1</code>: requesting information (if <code>d</code> is undefined) or sending information</li><li><code>2</code>: terminating the relationship</li></ul><p>The initial exchanging of <code>(0, talkback)</code> messages is called a <em>handshake</em>. We&#x27;ll never send <code>1</code> or <code>2</code> before having performed a successful handshake.</p><p>In other words, we&#x27;ll send <code>0</code> to a callbag, but <code>1</code> and <code>2</code> are only sent to a talkback that was provided via a handshake (but technically the talkback is a callbag too).</p><p>Another observation: a <em>source</em> is simply a callbag who will shake your hand back if you call it with <code>(0, talkback)</code>. A <em>sink</em> is a callbag who takes the initiative to a handshake.</p><h3 id="pushing-and-pulling">Pushing and pulling</h3><p>In the callbag world there are two different kinds of sources:</p><ul><li>A source is <em>listenable</em> if it <em>pushes</em> data to the source. The sink just needs to subscribe, and after that the data is sent down along the wire whenever the source deems appropriate.</li><li>It is <em>pullable</em> if the source has to <em>pull</em> each piece of data from it. Data is only ever sent as a response to a date request.</li></ul><p>Being able to represent both push and pull with the same spec is one of the main strengths of callbags. Most stream libraries can only do one or the other - for instance, <a href="https://github.com/reactivex/rxjs">RxJS</a> is all push (&quot;reactive programming&quot;), while the evil twin <a href="https://github.com/ReactiveX/IxJS">IxJS</a> is all pull (&quot;iterative programming&quot;).</p><p>How did André manage this? Through the realisation that <strong>a pull is simply two pushes</strong>:</p><ol><li>the sink pushes a request message to the pullable (<code>pullableTalkback(1)</code>)</li><li>the pullable pushes the response back (<code>sinkTalkback(1, data)</code>)</li></ol><p>In other words, you&#x27;d never call a listenable source with <code>(1)</code> - there&#x27;s no need, it will send data to you whenever it sees fit.</p><h3 id="sources">Sources</h3><p>As a first look at a callbag example, here&#x27;s the source code for Staltz&#x27; <a href="https://github.com/staltz/callbag-interval">callbag-interval</a> which creates a source that emits at an interval:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> interval = <span class="hljs-function"><span class="hljs-params">period</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">start, sink</span>) =&gt;</span> {<br/>  <span class="hljs-keyword">if</span> (start !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br/>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br/>  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {<br/>    sink(<span class="hljs-number">1</span>, i++);<br/>  }, period);<br/>  sink(<span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> { <span class="hljs-comment">// &lt;--- here we send the talkback to the sink</span><br/>    <span class="hljs-keyword">if</span> (t === <span class="hljs-number">2</span>) <span class="hljs-built_in">clearInterval</span>(id);<br/>  });<br/>};</code></pre><p>That was an example of a listenable source, since it pushes messages to the listener without it having to request it.</p><p>Why was the signature of the callbag <code>(start, sink)</code> and not <code>(t, d)</code> in the code? To signify that it only ever expects to be called with <code>0</code>. Subsequent calls will be made to the returned talkback.</p><p>Why is the signature of the talkback <code>(t)</code> and not <code>(t,d)</code>? Because it only ever expects to be called with <code>(2)</code>. Also this is a listenable source so there&#x27;s no need to send <code>(1)</code> data requests, so the parameter could really have been named <code>end</code> instead of <code>t</code>.</p><p>An example of the opposite, a pullable source, would be Staltz&#x27; <a href="https://github.com/staltz/callbag-from-iter">callbag-from-iter</a> It creates a source from an array (or other iterable) and then emits the next item in the array whenever asked to. Here&#x27;s an abbreviated version of the code:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> fromIter = <span class="hljs-function"><span class="hljs-params">iter</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">start, sink</span>) =&gt;</span> {<br/>  <span class="hljs-keyword">if</span> (start !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br/>  <span class="hljs-comment">/* prepare iterable here */</span><br/>  sink(<span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> {<br/>    <span class="hljs-keyword">if</span> (t === <span class="hljs-number">1</span>) {<br/>      <span class="hljs-comment">/* send next item in iterable (unless terminated or pending request) */</span><br/>    }<br/>  });<br/>};</code></pre><p>Note how it only sends data when the sink calls the talkback with <code>(1)</code>.</p><h3 id="sinks">Sinks</h3><p>Let&#x27;s also look at Staltz&#x27; <a href="https://github.com/staltz/callbag-for-each">callbag-for-each</a> for an example of a basic <em>sink</em>:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> forEach = <span class="hljs-function"><span class="hljs-params">operation</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> {<br/>  <span class="hljs-keyword">let</span> talkback;<br/>  source(<span class="hljs-number">0</span>, <span class="hljs-function">(<span class="hljs-params">t, d</span>) =&gt;</span> {<br/>    <span class="hljs-keyword">if</span> (t === <span class="hljs-number">0</span>) talkback = d;<br/>    <span class="hljs-keyword">if</span> (t === <span class="hljs-number">1</span>) operation(d);<br/>    <span class="hljs-keyword">if</span> (t === <span class="hljs-number">1</span> || t === <span class="hljs-number">0</span>) talkback(<span class="hljs-number">1</span>);<br/>  });<br/>};</code></pre><p>The <code>forEach</code> sink performs the given operation on every emission on the connected source. We could use it on the interval source like so:</p><pre><code class="hljs language-javascript">forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))(interval(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 0</span><br/>                                             <span class="hljs-comment">// 1</span><br/>                                             <span class="hljs-comment">// 2</span></code></pre><p>To more clearly see the flow of stream juggling it is common to use Staltz&#x27; <a href="https://github.com/staltz/callbag-pipe">callbag-pipe</a> utility function. Using that we can rephrase the above to this:</p><pre><code class="hljs language-javascript">pipe(<br/>  interval(<span class="hljs-number">100</span>),<br/>  forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v)) <span class="hljs-comment">// 0</span><br/>);                             <span class="hljs-comment">// 1</span><br/>                               <span class="hljs-comment">// 2</span></code></pre><p>The <code>forEach</code> sink is clever in that it works with both <code>listenable</code> and <code>pullable</code> sources. Notice this line in the sink talkback in the code:</p><pre><code class="hljs">if (<span class="hljs-name">t</span> === <span class="hljs-number">1</span> || <span class="hljs-literal">t</span> === <span class="hljs-number">0</span>) talkback(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span></code></pre><p>This calls the source talkback with a data request after initiation and after each received data. If the source is pullable, this means it will send the next data. If it isn&#x27;t the request is simply ignored.</p><h3 id="callbag-operators">Callbag operators</h3><p>An operator is simply a function that takes an argument (or more), returns a function that takes a callbag source which in turn returns a transformed source.</p><pre><code class="hljs language-typescript">(...args: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;) =&gt; <span class="hljs-function">(<span class="hljs-params">source: Callbag</span>) =&gt;</span> Callbag;</code></pre><p>As an example, here&#x27;s Staltz&#x27; <a href="https://github.com/staltz/callbag-map">callbag-map</a>:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">start, sink</span>) =&gt;</span> {<br/>  <span class="hljs-keyword">if</span> (start !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br/>  source(<span class="hljs-number">0</span>, <span class="hljs-function">(<span class="hljs-params">t, d</span>) =&gt;</span> {<br/>    sink(t, t === <span class="hljs-number">1</span> ? f(d) : d)<br/>  });<br/>};</code></pre><p>This returns a new source that passes each emitted data through the mapping function <code>f</code>.</p><p>We could use that on the previously shown <code>callbag-interval</code> like so:</p><pre><code class="hljs language-javascript">pipe(<br/>  interval(<span class="hljs-number">100</span>),<br/>  map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-number">2</span>*v),<br/>  forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v)) <span class="hljs-comment">// 0</span><br/>);                             <span class="hljs-comment">// 2</span><br/>                               <span class="hljs-comment">// 4</span></code></pre><p>In other words Callbag code (much like any stream code) is often a chain of sources passing through operators with a sink at the end:</p><p><img src="/static/posts/callbags-introduction/diagrams/callbag-chain.svg" alt=""/></p><h3 id="wrapping-up">Wrapping up</h3><p>Here&#x27;s the real kicker regarding callbags - there&#x27;s <em>no core library</em>. Working with callbags means working with a bunch of different functions that all follow the spec.</p><p>In my mind the spec that Staltz has created is a remarkable feat. Much like Crockford likes to say he didn&#x27;t <em>invent</em> JSON as much as <em>discover</em> it, I feel Staltz can say the exact same thing about callbags. </p><p>There is already a <a href="https://npms.io/search?q=keywords%3Acallbag">significant number of callbag packages</a> out there. And if something you need isn&#x27;t there, it is super easy to roll your own.</p><p>For more in-depth detail about callbags check out the following links:</p><ul><li>Staltz&#x27; <a href="https://staltz.com/why-we-need-callbags.html">blog post introducing callbags</a></li><li>The <a href="https://github.com/callbag/callbag">callbag spec</a></li><li>The <a href="https://github.com/callbag/callbag/blob/master/getting-started.md">getting started guide</a> hidden in the spec</li></ul><p>Also, for a more practical exercise, check out the <a href="/posts/dissecting-a-callbag-todomvc-implementation/">next post</a> where we dissect a TodoMVC app implemented with callbags!</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/callbags-introduction","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/callbags-introduction" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/callbags-introduction.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>