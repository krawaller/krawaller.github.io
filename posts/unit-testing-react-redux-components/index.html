<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Unit testing ReactRedux components</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/unit-testing-react-redux-components.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">A convenient approach for testing React components connected via ReactRedux</div><hr/><h2>Unit testing ReactRedux components</h2><p class="taglist">Tags:<!-- --> <a href="/tags/react/">react</a><a href="/tags/redux/">redux</a><a href="/tags/testing/">testing</a><a href="/tags/jest/">jest</a></p><div class="page-content"><div class="post" data-postid="unittestingreactredux"><h3 id="premise">Premise</h3><p>This article explores how to test a React component that is connected to Redux via <code>ReactRedux</code>.</p><p>In doing that we will also establish some patterns for making good tests in general.</p><h3 id="test-subject">Test subject</h3><p>Here&#x27;s the (semi-)imaginary component that we want to test:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CurrentLegoSetImage = <span class="hljs-function">() =&gt;</span> {<br/>  <span class="hljs-keyword">const</span> set = useSelector(selectCurrentSet);<br/>  <span class="hljs-keyword">const</span> dispatch = useDispatch();<br/>  <span class="hljs-keyword">const</span> zoomHandler = <span class="hljs-function">() =&gt;</span> dispatch(zoomToImage(set.imgUrl));<br/>  <span class="hljs-keyword">return</span> (<br/>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;legoImg&quot;</span>&gt;</span><br/>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{zoomHandler}</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{set.imgUrl}</span> <span class="hljs-attr">data-testid</span>=<span class="hljs-string">&quot;setimg&quot;</span> /&gt;</span><br/>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br/>  );<br/>};</code></pre><p>Looking at the code, there seems to be two pieces of functionality we could cover with unit tests:</p><ol><li>it renders the current set image</li><li>it dispatches correct action when image is clicked</li></ol><p>Let&#x27;s begin with the first one!</p><h3 id="arranging---how-not-to-do-it">Arranging - how not to do it</h3><p>So - how do we test that the component renders the current set image?</p><p>A na√Øve approach would be to notice this line...</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> set = useSelector(selectCurrentSet);</code></pre><p>...and decide to simply mock <code>selectCurrentSet</code> to return a fixture set.</p><pre><code class="hljs language-javascript">jest.mock(<span class="hljs-string">&quot;../selectors&quot;</span>, <span class="hljs-function">() =&gt;</span> ({<br/>  ...jest.requireActual(<span class="hljs-string">&quot;../selectors&quot;</span>),<br/>  <span class="hljs-attr">selectCurrentSet</span>: jest.fn().mockReturnValue(fixtureSet),<br/>}));</code></pre><p>But this has big downside; we have now made assumptions about the component implementation in our test. If we change the component to use a different selector, the test will stop working.</p><p>Mocking <code>useSelector</code> isn&#x27;t better. We&#x27;re still in implementation detail land, as we then assume we&#x27;re dealing with a hook component and not a class component using the ReactRedux <code>.connect</code> method.</p><h3 id="arranging---another-way-of-how-not-to-do-it">Arranging - another way of how not to do it</h3><p>We don&#x27;t want our test to mess with how the component connects to the store. Instead we want to ensure our store gets the state we need, and then let the component do its thing.</p><p>So we could hand-craft the app state we need:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> testAppState = {<br/>  ...defaultAppState,<br/>  <span class="hljs-attr">sets</span>: {<br/>    ...defaultAppState.sets,<br/>    <span class="hljs-attr">data</span>: {<br/>      [fixtureSet.id]: fixtureSet, <span class="hljs-comment">// injecting the fixture set into the data</span><br/>    },<br/>  },<br/>  <span class="hljs-attr">ui</span>: {<br/>    ...defaultAppState.ui,<br/>    <span class="hljs-attr">currentSetId</span>: fixtureSet.id, <span class="hljs-comment">// setting our fixture set as the &quot;current&quot; set</span><br/>  },<br/>};</code></pre><p>And then use that state to seed a new store instance:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> store = createStore(rootReducer, testAppState);</code></pre><p>Now we can use that store in our test, and things should be dandy.</p><p>But, this still isn&#x27;t ideal!</p><ul><li>We&#x27;re depending on knowing the shape of the state (granted, not a biggie if we&#x27;re using TS, but still inelegant)</li><li>We run the risk of testing a scenario that isn&#x27;t achievable in actual app usage, which could mean the test is pointless</li></ul><h3 id="arranging-yet-another-way-of-not-doing-it">Arranging, yet another way of not doing it.</h3><p>Instead, we want to get our fixture set into place the same way it normally would get there - by firing actions!</p><p>So, what if we do this?</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// injecting the fixture set into the data</span><br/>store.dispatch({<br/>  <span class="hljs-attr">type</span>: LOAD_SETS_SUCCESS,<br/>  <span class="hljs-attr">payload</span>: {<br/>    [fixtureSet.id]: fixtureSet,<br/>  },<br/>});<br/><span class="hljs-comment">// setting our fixture set as the &quot;current&quot; set</span><br/>store.dispatch({<br/>  <span class="hljs-attr">type</span>: SET_CURRENT_SET,<br/>  <span class="hljs-attr">payload</span>: {<br/>    <span class="hljs-attr">id</span>: fixtureSet.id,<br/>  },<br/>});</code></pre><p>Now our state will contain the correct state!</p><p>This still isn&#x27;t ideal though - we have hand-crafted actions, which should only ever be done in action creators.</p><h3 id="arranging-how-to-actually-do-it">Arranging, how to actually do it</h3><p>Therefore we refactor our previous failing into this:</p><pre><code class="hljs language-javascript">store.dispatch(loadSetsSuccess({ [fixtureSet.id]: fixtureSet }));<br/>store.dispatch(setCurrentSet(fixtureSet.id));</code></pre><p>Now we&#x27;re truly using the same API versus the Redux layer as a user using the app!</p><p>It also makes the test setup very readable, if you&#x27;ve named your action creators appropriately.</p><h3 id="acting---rendering-strategies">Acting - rendering strategies</h3><p>Now our test wants to render our component within the context of that store. How do we do that?</p><p>As a reminder, this is what a <code>testing-library</code> React component unit test usually looks like:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@testing-library/react&quot;</span>;<br/><br/><span class="hljs-comment">// ...and inside a single test:</span><br/><br/><span class="hljs-keyword">const</span> testLibAPI = render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CurrentLegoSetImage</span> /&gt;</span></span>);<br/><br/><span class="hljs-comment">// ...and now we use stuff from testLibAPI to assert things</span></code></pre><p>The simplest way to use the store with our test state would be to wrap the JSX given to the test library <code>render</code> function with the ReactRedux store provider:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> testLibAPI = render(<br/>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span><br/>    <span class="hljs-tag">&lt;<span class="hljs-name">CurrentLegoSetImage</span> /&gt;</span><br/>  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br/>);</code></pre><p>But having to do this for every single test render would grow old pretty fast!</p><h3 id="helpers-part-1---testrender">Helpers, part 1 - testRender</h3><p>Let&#x27;s make a helper function that does the provider wrapping for you:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@testing-library/react&quot;</span>;<br/><span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br/><br/><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testRender</span>(<span class="hljs-params">jsx, { store, ...otherOpts }</span>) </span>{<br/>  <span class="hljs-keyword">return</span> render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>{jsx}<span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>, otherOpts);<br/>}</code></pre><p>Now our test becomes this instead:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> testLibAPI = testRender(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">some</span>=<span class="hljs-string">{props}</span>&gt;</span>, { store });</span></code></pre><p>We still have to pass in our <code>store</code> among the other options for every render, but I prefer that to some magical <code>beforeEach</code> dance (which could mean leaking state between tests).</p><h3 id="asserting-render">Asserting render</h3><p>With what we&#x27;ve talked about so far, we have enough to write a full test for ensuring that <code>CurrentLegoSetImage</code> renders the correct image:</p><pre><code class="hljs language-javascript">describe(<span class="hljs-string">&quot;The CurrentLegoSetImage component&quot;</span>, <span class="hljs-function">() =&gt;</span> {<br/>  it(<span class="hljs-string">&quot;shows the correct image&quot;</span>, <span class="hljs-function">() =&gt;</span> {<br/>    <span class="hljs-comment">// Arrange</span><br/>    <span class="hljs-keyword">const</span> store = makeStore(); <span class="hljs-comment">// same func we use in the actual app, gives us a normal Redux store</span><br/>    store.dispatch(loadSetsSuccess({ [fixtureSet.id]: fixtureSet }));<br/>    store.dispatch(setCurrentSet(fixtureSet.id));<br/><br/>    <span class="hljs-comment">// Act</span><br/>    <span class="hljs-keyword">const</span> { getByTestId } = testRender(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LegoSetImage</span> /&gt;</span></span>, { store });<br/><br/>    <span class="hljs-comment">// Assert</span><br/>    <span class="hljs-keyword">const</span> img = getByTestId(<span class="hljs-string">&quot;setimg&quot;</span>);<br/>    expect(img).toHaveAttribute(<span class="hljs-string">&quot;src&quot;</span>, fixtureSet.imgUrl);<br/>  });<br/>});</code></pre><p>Readable, no assumptions about implementation detail, no mocking or other magic.</p><h3 id="acting-behaviour">Acting behaviour</h3><p>But, that was just the first half of the testing done. As we said initially we also need to test the zooming functionality!</p><p>Here&#x27;s the code in the component that we want to test:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> zoomHandler = <span class="hljs-function">() =&gt;</span> dispatch(zoomToImage(set.imgUrl));</code></pre><p>In other words, we want to ensure that when the image is clicked, a zoom happens.</p><p>Doing the click in our test is easy enough. We get hold of the <code>fireEvent</code> helper from the testing library...</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { fireEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@testing-library/react&quot;</span>;</code></pre><p>...and then simply use that to fire the click on the rendered <code>img</code> element in our unit test:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { getByTestId } = testRender(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LegoSetImage</span> /&gt;</span></span>, { store });<br/><span class="hljs-keyword">const</span> img = getByTestId(<span class="hljs-string">&quot;setimg&quot;</span>);<br/>fireEvent.click(img);</code></pre><p>But, then what? What should we actually test for now?</p><h3 id="asserting-behaviour-how-not-to-do-it">Asserting behaviour, how not to do it</h3><p>One option could be to check the store state after the event:</p><pre><code class="hljs language-javascript">expect(store.getState().ui.zoomedImage).toBe(fixtureSet.imgUrl);</code></pre><p>This isn&#x27;t ideal though - now we&#x27;re testing the behaviour of the <code>zoomToImage</code> action, not the component. Likely the code we just wrote is identical to a unit test for <code>zoomToImage</code> elsewhere, which isn&#x27;t very DRY.</p><h3 id="asserting-behaviour-how-still-not-to-do-it">Asserting behaviour, how still not to do it</h3><p>Instead, we just want to assert that the correct action was fired to the store! If <code>store.dispatch</code> was wrapped in a spy, we could do something like this:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> zoomAction = {<br/>  <span class="hljs-attr">type</span>: ZOOM_TO_IMAGE_URL,<br/>  <span class="hljs-attr">payload</span>: {<br/>    <span class="hljs-attr">url</span>: fixtureSet.imgUrl,<br/>  },<br/>};<br/>expect(store.dispatch).toHaveBeenCalledWith(zoomAction);</code></pre><p>Now we&#x27;re not testing the consequence of the zoom, we&#x27;re just ensuring that the zoom happened. Which is exactly what we wanted!</p><p>But, of course, we re-committed our earlier sin of handcrafting action objects.</p><h3 id="asserting-behaviour-how-to-do-it">Asserting behaviour, how to do it</h3><p>Here&#x27;s the final version where we use the action creator in the assertion:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> zoomAction = zoomToImage(fixtureSet.imgUrl);<br/>expect(store.dispatch).toHaveBeenCalledWith(zoomAction);</code></pre><p>Much like when we rephrased the acting part we find that through using action creators we get very readable tests! And, as we&#x27;ve already established, it also has the added benefit of actually testing the correct API surface.</p><h3 id="helpers-part-2---teststore">Helpers, part 2 - testStore</h3><p>But now we&#x27;ve just been imagining that <code>store.dispatch</code> is wrapped in a spy. How do we accomplish that?</p><p>Remember how we made a thin <code>testRender</code> wrapper around <code>render</code> from the testing library? In the same vein we can make a <code>makeTestStore</code> wrapper around <code>makeStore</code> from our app!</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> makeTestStore = <span class="hljs-function">(<span class="hljs-params">store</span>) =&gt;</span> {<br/>  <span class="hljs-keyword">const</span> store = makeStore();<br/>  <span class="hljs-keyword">const</span> origDispatch = store.dispatch;<br/>  store.dispatch = jest.fn(origDispatch);<br/>  <span class="hljs-keyword">return</span> store;<br/>};</code></pre><p>Again, <code>makeStore</code> here is just the main store constructor function that I use in my app. It likely looks something like this:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<br/><br/><span class="hljs-keyword">const</span> makeStore = <span class="hljs-function">() =&gt;</span> {<br/>  <span class="hljs-comment">// ...code here to create enhancers and the other stuff...</span><br/>  <span class="hljs-keyword">return</span> createStore(rootReducer, initialAppState, compose(...enhancers));<br/>};</code></pre><h3 id="the-full-unit-test">The full unit test</h3><p>If we piece everything together, here&#x27;s the full test for our component:</p><pre><code class="hljs language-javascript">describe(<span class="hljs-string">&quot;The CurrentLegoSetImage component&quot;</span>, <span class="hljs-function">() =&gt;</span> {<br/>  it(<span class="hljs-string">&quot;shows the correct image and zooms on click&quot;</span>, <span class="hljs-function">() =&gt;</span> {<br/>    <span class="hljs-comment">// Arrange</span><br/>    <span class="hljs-keyword">const</span> store = makeTestStore();<br/>    store.dispatch(loadSetsSuccess({ [fixtureSet.id]: fixtureSet }));<br/>    store.dispatch(setCurrentSet(fixtureSet.id));<br/><br/>    <span class="hljs-comment">// Act</span><br/>    <span class="hljs-keyword">const</span> { getByTestId } = testRender(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LegoSetImage</span> /&gt;</span></span>, { store });<br/><br/>    <span class="hljs-comment">// Assert</span><br/>    <span class="hljs-keyword">const</span> img = getByTestId(<span class="hljs-string">&quot;setimg&quot;</span>);<br/>    expect(img).toHaveAttribute(<span class="hljs-string">&quot;src&quot;</span>, fixtureSet.imgUrl);<br/><br/>    <span class="hljs-comment">// Act</span><br/>    fireEvent.click(getByTestId(<span class="hljs-string">&quot;setimg&quot;</span>));<br/><br/>    <span class="hljs-comment">// Assert</span><br/>    expect(store.dispatch).toHaveBeenCalledWith(zoomImage(setImageUrl));<br/>  });<br/>});</code></pre><p>Purists might argue that this test should be split in two, but, you get the idea!</p><h3 id="wrapping-up">Wrapping up</h3><p>To bring things home; the main point of this article is to try to test the API surface of the Redux layer, however we connect our React tree to it.</p><p>We strive to avoid testing implementation detail, which I feel we achieved. Our final test version is almost completely independent of <code>ReactRedux</code> - if we were to change it out for another bridging solution, the only change we&#x27;d need to make is to swap out <code>Provider</code> in <code>testRender</code>!</p><p>And, perhaps most importantly; testing your component with this strategy also means you end up with very readable and robust tests!</p><h3 id="ps">PS</h3><p>One could absolutely discuss whether the functionality in this rather trivial component is worth testing. I argue it is, but at the same time I can understand taking a more pragmatic approach and choosing one&#x27;s battles more strategically.</p><p>But that&#x27;s a topic for another article!</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/unit-testing-react-redux-components","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/unit-testing-react-redux-components" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/unit-testing-react-redux-components.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>