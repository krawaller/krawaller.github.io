<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Exploring Redux middleware</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/exploring-redux-middleware.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Nine simple stand-alone experiments to understand Redux Middlewares</div><hr/><h2>Exploring Redux middleware</h2><p class="taglist">Tags:<!-- --> <a href="/tags/redux/">redux</a></p><div class="page-content"><div class="post" data-postid="undefined"><h3 id="0-the-premise">0. The premise</h3><p>This blog post is made up by 9 tiny self-contained experiments aiming to <strong>better our understanding of Redux middlewares</strong>. You are assumed to be familiar with the basic functionality of Redux. If you&#x27;re not then <a href="http://redux.js.org/">go remedy that immediately</a>, and let it be known that I&#x27;m severely jealous of you for still having that experience in front of you!</p><p>Throughout we&#x27;ll use a ridiculously simple <strong>counter reducer</strong>, based off of Redux creator Dan Abramov&#x27;s <a href="https://twitter.com/dan_abramov/status/664135757297295360">minimal Redux example</a>. It knows only of a single action, <code>INCREMENT</code>, and when that is encountered it increases state with the <code>by</code> payload (thus the state is not an object but a simple number):</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> reducer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)</span>{<br/>    <span class="hljs-keyword">switch</span>(action.type){<br/>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>: <span class="hljs-keyword">return</span> (state || <span class="hljs-number">0</span>) + (action.by || <span class="hljs-number">1</span>);<br/>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> state;<br/>    }<br/>}</code></pre><p>Just to try this out we can create a store with no middlewares:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> store = Redux.createStore(reducer);</code></pre><p>Assuming a <code>div</code> with id <code>app</code> we whip up a render function:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> render = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>    <span class="hljs-keyword">var</span> newhtml = <span class="hljs-string">&quot;&lt;h2&gt;Clicked &quot;</span>+store.getState()+<span class="hljs-string">&quot; times.&lt;/h2&gt;&quot;</span>;<br/>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>).innerHTML = newhtml;<br/>}</code></pre><p>We hook <code>render</code> up to run when the store updates, and we also run an initial render:</p><pre><code class="hljs language-javascript">store.subscribe(render);<br/>render();</code></pre><p>Finally we set a click event which dispatches an action to the store:</p><pre><code class="hljs"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<br/>    store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">by</span>: <span class="hljs-number">1</span> });<br/>});</code></pre><p>Try it out in the iframe below (or standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/nomiddleware.html">here</a>)</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/nomiddleware.html" height="100px" width="100%"></iframe><p>The following experiments will all be slight variations of this little app. Each will have a standalone link to an html document containing the full code, apart from Redux itself. There will be no other dependencies at all.</p><p>I&#x27;ll also be avoiding ES6 syntax to make it more clear what&#x27;s going on, as arrow functions and implicit returns tend to muddy the waters a bit.</p><h3 id="1-the-simplest-possible-middleware">1. The simplest possible middleware</h3><p>A middleware sits on top <code>store.dispatch</code>. Each middleware is given a dispatched action object, doing their thing before passing it on to the next middleware in line, until it finally reaches the original <code>store.dispatch</code> which will call the reducer.</p><p>To get a sense for what the middleware looks like, check out this simplest possible middleware which does nothing but pass the action along:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            <span class="hljs-keyword">return</span> next(action);<br/>        }<br/>    }<br/>}</code></pre><p>The <code>middlewareAPI</code> object we&#x27;re being passed up top contains <code>dispatch</code> and <code>getState</code>, letting us do all kinds of things should we want to. Here we&#x27;re only doing what we&#x27;re supposed to, namely passing the <code>action</code> on to the <code>next</code> in line, which in this case will be the actual <code>store.dispatch</code> since there&#x27;s no other middleware.</p><p>Just as a sanity check, let&#x27;s create a store using this useless middleware...</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> middlewares = Redux.applyMiddleware(noop);<br/><span class="hljs-keyword">var</span> store = Redux.createStore(reducer,middlewares);</code></pre><p>...and check that it is still functioning exactly like before (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/noop.html">here</a>):</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/noop.html" height="100px" width="100%"></iframe><p>Things appear to still be working as they should.</p><h3 id="2-a-breadcrumb-trail">2. A breadcrumb trail</h3><p>In order to decipher what&#x27;s going on, let&#x27;s add a logging mechanism to our app! We add a <code>&lt;div id=&quot;log&quot;/&gt;</code> to the page, and write to it using this <code>output</code> function:</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// put stuff into the log</span><br/><span class="hljs-keyword">var</span> output = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">txt</span>)</span>{<br/>    <span class="hljs-keyword">var</span> newparagraph = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br/>    newparagraph.innerHTML = txt;<br/>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;log&quot;</span>).appendChild(newparagraph);<br/>}</code></pre><p>Now we create a <code>logger</code> middleware which uses <code>output</code> to spy on what&#x27;s happening. Actually, let&#x27;s make a <code>loggerFactory(name)</code>, so we can have more than one <code>logger</code> with different names and track when the various parts of the middlewares are being called:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> loggerFactory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>        output(name+<span class="hljs-string">&quot;: created&quot;</span>);<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>            output(name+<span class="hljs-string">&quot;: middle callback called&quot;</span>);<br/>            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>                output(name+<span class="hljs-string">&quot;: inner callback called with action &quot;</span>+<span class="hljs-built_in">JSON</span>.stringify(action));<br/>                <span class="hljs-keyword">var</span> ret = next(action);<br/>                output(name+<span class="hljs-string">&quot;: State after calling next: &quot;</span>+middlewareAPI.getState());<br/>                <span class="hljs-keyword">return</span> ret;<br/>            }<br/>        }<br/>    }<br/>}</code></pre><p>Note how we use <code>middlewareAPI.getState</code> to query the updated state after the <code>next</code> call.</p><p>We create a store with two of these loggers:</p><pre><code class="hljs">var log1 = logger<span class="hljs-constructor">Factory(<span class="hljs-string">&quot;log1&quot;</span>)</span>,<br/>    log2 = logger<span class="hljs-constructor">Factory(<span class="hljs-string">&quot;log2&quot;</span>)</span>,<br/>    middlewares = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Redux</span>.</span></span>apply<span class="hljs-constructor">Middleware(<span class="hljs-params">log1</span>,<span class="hljs-params">log2</span>)</span>,<br/>    store = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Redux</span>.</span></span>create<span class="hljs-constructor">Store(<span class="hljs-params">reducer</span>,<span class="hljs-params">middlewares</span>)</span>;</code></pre><p>It&#x27;s a bit spammy, but should give a good sense of what&#x27;s going on (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/logger.html">here</a>):</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/logger.html" height="400px" width="100%"></iframe><p>Matching the spam to the various parts of the middleware, here&#x27;s what we can deduce:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{ <span class="hljs-comment">// called at start, left to right</span><br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{ <span class="hljs-comment">// called at start, right to left</span><br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{ <span class="hljs-comment">// called per action</span><br/>            <span class="hljs-comment">// code before `next` call runs left to right</span><br/>            <span class="hljs-keyword">var</span> ret = next(action);<br/>            <span class="hljs-comment">// code after next call runs right to left</span><br/>            <span class="hljs-keyword">return</span> ret;<br/>        }<br/>    }<br/>}</code></pre><h3 id="3-having-some-fun">3. Having some fun</h3><p>Just to internalize our findings so far, let&#x27;s make some silly middlewares that messes about with the <code>next</code> call! First we have a <code>deaf</code> middleware which will only hear what you say a third of the time:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> deaf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            <span class="hljs-keyword">if</span> (!(i++%<span class="hljs-number">3</span>)) {<br/>                next(action);<br/>            }<br/>        }<br/>    }<br/>}</code></pre><p>Next we have <code>nervous</code> who will execute every action twice just to be sure:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> nervous = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            next(action);<br/>            next(action);<br/>        }<br/>    }<br/>}</code></pre><p>Finally there&#x27;s <code>impatient</code> who will set <code>.by</code> to 5 instead of the default 1:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> impatient = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            <span class="hljs-comment">// it is good form not to mutate action so we make a copy</span><br/>            next(<span class="hljs-built_in">Object</span>.assign({},action,{<span class="hljs-attr">by</span>:<span class="hljs-number">5</span>}));<br/>        }<br/>    }<br/>}</code></pre><p>We whip up a store using all three, in the mentioned order:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> middlewares = Redux.applyMiddleware(deaf,nervous,impatient),<br/>    store = Redux.createStore(reducer,middlewares);</code></pre><p>The net result should be that only every third click registers, but that click will increase the counter by 2*5 (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/havingsomefun.html">here</a>):</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/havingsomefun.html" height="100px" width="100%"></iframe><h3 id="4-snooping-at-final-next">4. Snooping at final <code>next</code></h3><p>Since the action eventually ends up with the regular <code>store.dispatch</code>, that implies that <code>next</code> inside the final middleware <strong>is</strong> the vanilla <code>store.dispatch</code>. Let&#x27;s see if that holds true! We make a middleware that makes the comparison: </p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> vanilladispatch = Redux.createStore(reducer).dispatch;<br/><span class="hljs-keyword">var</span> snoopForVanilla = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            <span class="hljs-keyword">var</span> comparison = (next.toString() === vanilladispatch.toString());<br/>            output(<span class="hljs-string">&quot;next === vanilla dispatch? &quot;</span>+comparison);<br/>            <span class="hljs-keyword">return</span> next(action);<br/>        }<br/>    }<br/>}</code></pre><p>Note how we cannot compare references directly since they obviously won&#x27;t be the same (as we picked <code>dispatch</code> from a non-middlewared throwaway store), so we turn them to strings before we check equality.</p><p>Now, let&#x27;s put it to the test (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/snoopvanillanaive.html">here</a>)!</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/snoopvanillanaive.html" height="120px" width="100%"></iframe><p>It seems our assumption was correct!</p><h3 id="5-snooping-at-following-middleware">5. Snooping at following middleware</h3><p>This raises a question - what is <code>next</code> from the perspective of a middleware who <strong>isn&#x27;t</strong> last in the chain? Let&#x27;s revive or old friend the <code>noop</code> middleware:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(middlewareAPI)</span></span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(next)</span></span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(action)</span></span>{<br/>            <span class="hljs-keyword">return</span> next(action);<br/>        }<br/>    }<br/>}</code></pre><p>If we put it at the end and a snooper before it, what would that snooper actually see? An easy way to test that would be to simply log out <code>next</code>, so let&#x27;s create a snooper doing that:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> snooper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            output(<span class="hljs-string">&quot;snooping at `next`: &quot;</span>+next);<br/>            <span class="hljs-keyword">return</span> next(action);<br/>        }<br/>    }<br/>}</code></pre><p>We put both in a store, taking care to put <code>snooper</code> before <code>noop</code>:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> middlewares = Redux.applyMiddleware(snooper,noop),<br/>    store = Redux.createStore(reducer,middlewares);</code></pre><p>...and voilà (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/snoopatfriend.html">here</a>):</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/snoopatfriend.html" height="150px" width="100%"></iframe><p>Evidently the inner part of the middleware becomes the <code>next</code>. Which makes sense as the inner part is what takes the action as an argument, and it is the action we&#x27;re feeding to <code>next</code>!</p><p>Curious what would happen if we put snooper last in the chain? You&#x27;d get a facefull of <a href="https://github.com/reactjs/redux/blob/e7295c33776be6199b826817934dadad5d0f9bb1/src/createStore.js#L148-L180">Redux source code</a> is what, spelling out the entrails of the <code>dispatch</code> method. Hack the standalone version and try it!</p><h3 id="6-dispatch-return-value">6. Dispatch return value</h3><p>Ok, so the middleware passes the action along by calling the <code>next</code> it is given. But why does it return the result of that <code>next</code> call? Since the action chain is done through the <code>next</code> call, what purpose does that return value serve? </p><p>A clue might be that the <a href="http://redux.js.org/docs/api/Store.html#dispatch">documentation says</a> that <code>store.dispatch(action)</code> returns the action you passed in. The docs also notes, however, that middlewares can mess with the return value.</p><p>First off, let&#x27;s just hack the click handler to also output the return from <code>dispatch</code> to the log:</p><pre><code class="hljs"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<br/>    <span class="hljs-keyword">var</span> ret = store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">by</span>: <span class="hljs-number">1</span> });<br/>    output(<span class="hljs-string">&quot;return: &quot;</span>+<span class="hljs-built_in">JSON</span>.stringify(ret));<br/>});</code></pre><p>We run this with a no-middleware store (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/outputreturn.html">here</a>):</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/outputreturn.html" height="150px" width="100%"></iframe><p>Unsurprisingly it seems the docs told the truth - we simply get the action object back.</p><p>And, also unsurprisingly, if we insert a stupid middleware which returns some bogus crap:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> sillynoop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            next(action);<br/>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WOO!&quot;</span>;<br/>        }<br/>    }<br/>}</code></pre><p>...then bogus crap is what comes out at the end of the chain, even if we put a regular noop before and after:</p><pre><code class="hljs language-javascript"><span class="hljs-comment">// setting up the store</span><br/><span class="hljs-keyword">var</span> middlewares = Redux.applyMiddleware(noop,sillynoop,noop),<br/>    store = Redux.createStore(reducer,middlewares);</code></pre><p>See for yourself (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/outputreturnsilly.html">here</a>):</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/outputreturnsilly.html" height="150px" width="100%"></iframe><h3 id="7-localstorage-getsate">7. Localstorage getsate</h3><p>We&#x27;ve utlized <code>middlewareAPI.getState</code> in the <code>logger</code> middleware. Here&#x27;s another quick example of a more practical use; a <code>persist</code> middleware which uses <code>middlewareAPI.getState</code> to store the whole store state to <code>localStorage</code> for every change.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> persist = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            <span class="hljs-keyword">var</span> ret = next(action),<br/>                str = <span class="hljs-built_in">JSON</span>.stringify({<span class="hljs-attr">data</span>:middlewareAPI.getState()});<br/>            <span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">&quot;SAVESTATE&quot;</span>,str);<br/>            <span class="hljs-keyword">return</span> ret;<br/>        }<br/>    }<br/>}</code></pre><p>We put this in a store, and seed it with data from localStorage as initial state:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> savedstr = <span class="hljs-built_in">window</span>.localStorage.getItem(<span class="hljs-string">&quot;SAVESTATE&quot;</span>)||<span class="hljs-string">&quot;{}&quot;</span>,<br/>    initialstate = <span class="hljs-built_in">JSON</span>.parse(savedstr).data,<br/>    middlewares = Redux.applyMiddleware(persist),<br/>    store = Redux.createStore(reducer,initialstate,middlewares);</code></pre><p>Give it a few clicks below, then reload the page to watch the counter remember its position (and not at <em>all</em> to give me extra page views).</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/persistence.html" height="100px" width="100%"></iframe><p>Standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/persistence.html">here</a>.</p><h3 id="8-the-injected-dispatch">8. The injected <code>dispatch</code></h3><p>We&#x27;ve utlized <code>middlewareAPI.getState</code> in the <code>logger</code> middleware. The use of it is pretty obvious. But what about the other method on the <code>middlewareAPI</code>, namely <code>dispatch</code>? At first glance it doesn&#x27;t really make sense. To continue the action chain we merely call <code>next</code>, as we&#x27;ve seen several times over. Why would we want to start a new chain?</p><p>Just to test that this is really what will happen (because who knows, maybe <code>middlewareAPI.dispatch</code> is a wormhole to the final <code>dispatch</code> in the chain?), let&#x27;s make a silly <code>echo</code> middleware:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> echo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            <span class="hljs-keyword">if</span> (action.type !== <span class="hljs-string">&#x27;ECHO&#x27;</span>){<br/>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                    middlewareAPI.dispatch({<br/>                        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ECHO&#x27;</span>,<br/>                        <span class="hljs-attr">volume</span>: <span class="hljs-number">3</span><br/>                    });<br/>                },<span class="hljs-number">500</span>);<br/>                <span class="hljs-keyword">return</span> next(action);<br/>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action.volume){<br/>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                    middlewareAPI.dispatch({<br/>                        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ECHO&#x27;</span>,<br/>                        <span class="hljs-attr">volume</span>: action.volume - <span class="hljs-number">1</span><br/>                    });<br/>                },<span class="hljs-number">500</span>);<br/>            }<br/>        }<br/>    }<br/>}</code></pre><p>If the action it is given isn&#x27;t an <code>ECHO</code>, it will start a new chain with an <code>ECHO</code> action with <code>volume</code> 3. If it was an echo it will repeat it with one less volume unit, until the echo fades. Note that we&#x27;re swallowing all <code>ECHO</code> actions, not passing them along to <code>next</code>.</p><p>In order to see this in action let&#x27;s also revive our <code>loggerFactory</code>, although slightly less spammy this time:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> loggerFactory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>                <span class="hljs-keyword">var</span> ret = next(action),<br/>                    newstate = middlewareAPI.getState();<br/>                output(name+<span class="hljs-string">&quot;: called with &quot;</span>+<span class="hljs-built_in">JSON</span>.stringify(action)+<span class="hljs-string">&quot;, state now &quot;</span>+newstate);<br/>                <span class="hljs-keyword">return</span> ret;<br/>            }<br/>        }<br/>    }<br/>}</code></pre><p>We set up a store with the <code>echo</code> middleware sandwiched between two <code>logger</code>s:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> log1 = loggerFactory(<span class="hljs-string">&quot;log1&quot;</span>),<br/>    log2 = loggerFactory(<span class="hljs-string">&quot;log2&quot;</span>),<br/>    middlewares = Redux.applyMiddleware(log1,echo,log2),<br/>    store = Redux.createStore(reducer,middlewares);</code></pre><p>Try it out (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/testingdispatch.html">here</a>)!</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/testingdispatch.html" height="400px" width="100%"></iframe><h3 id="9-redux-thunk">9. Redux-thunk</h3><p>So the previous experiment merely proved that <code>middlewareAPI.dispatch</code> is a way to start a new chain, something which on the surface seems pretty useless. Here&#x27;s a very good example for when it <em>is</em> useful: <a href="https://github.com/gaearon/redux-thunk">Redux-thunk</a>. It is a middleware where the source code looks like this:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> thunk = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middlewareAPI</span>)</span>{<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>)</span>{<br/>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span>){<br/>                <span class="hljs-keyword">return</span> action(middlewareAPI.dispatch,middlewareAPI.getState);<br/>            } <span class="hljs-keyword">else</span> {<br/>                <span class="hljs-keyword">return</span> next(action);<br/>            }<br/>        }<br/>    }<br/>}</code></pre><p>So what&#x27;s going on here? It checks if <code>action</code> is a function (what?!), and if so it invokes that function with <code>dispatch</code> and <code>getState</code> from the <code>middlewareAPI</code>. If <code>action</code> is not a function, it simply passes it on to <code>next</code> as per usual.</p><p>The point of this is to enable developers to have action creators that are async. Let&#x27;s take a look again at how the counter click handler is set in our experiments:</p><pre><code class="hljs"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<br/>    store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">by</span>: <span class="hljs-number">1</span> });<br/>});</code></pre><p>In normal Redux usage, like for example in a React app using the <a href="https://github.com/reactjs/react-redux">React-Redux</a> bridge, you won&#x27;t pass around a reference to the store itself. Instead you&#x27;ll pass around action creators, and have some central system feed whatever they return to <code>store.dispatch</code>. Translating our code above, that might look something like this:</p><pre><code class="hljs"><span class="hljs-comment">// these action creators are what &quot;views&quot; in your app will use</span><br/><span class="hljs-keyword">var</span> actionCreators = {<br/>    increase: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inc</span>)</span>{<br/>         <span class="hljs-comment">// we return an action that&#x27;ll go to the `dispatch` chain</span><br/>        <span class="hljs-keyword">return</span> {type: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, by: inc};<br/>    }<br/>}<br/><br/><span class="hljs-comment">// The views will use the actionCreators through a bridge to the dispatch method:</span><br/><span class="hljs-keyword">var</span> bridge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch</span>)</span>{<br/>    <span class="hljs-keyword">return</span> {<br/>        increase: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inc</span>)</span>{ dispatch(actions.increase(inc)); }<br/>    }<br/>};</code></pre><p>The point of the bridge is that we don&#x27;t pass the store or <code>dispatch</code> around, we just provide it at hookup time by passing it to the bridge function.</p><p>This model as seen so far doesn&#x27;t really allow for defining async actions in a smooth way. Sure, we could do some async stuff in our <code>bridge</code> function above, but ideally we&#x27;d like to have that logic in the <code>actionCreators</code> definition. This is what <code>Redux-thunk</code> allows us to do. Remember how it checked if an action was a function, and if so invoked that? That allows us to do stuff like this (this is an extract from our <a href="a-react-redux-firebase-app-with-authentication/">Redux Firebase example</a>): </p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> actionCreators = {<br/>    <span class="hljs-attr">startQuoteEdit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">qid</span>)</span>{<br/>        <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>:C.START_QUOTE_EDIT,qid};<br/>    },<br/>    <span class="hljs-attr">cancelQuoteEdit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">qid</span>)</span>{<br/>        <span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>:C.FINISH_QUOTE_EDIT,qid};<br/>    },<br/>    <span class="hljs-attr">deleteQuote</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">qid</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch,getState</span>)</span>{<br/>            dispatch({<span class="hljs-attr">type</span>:C.SUBMIT_QUOTE_EDIT,qid});<br/>            quotesRef.child(qid).remove(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>{<br/>                dispatch({<span class="hljs-attr">type</span>:C.FINISH_QUOTE_EDIT,qid});<br/>                <span class="hljs-keyword">if</span> (error){<br/>                    dispatch({<span class="hljs-attr">type</span>:C.DISPLAY_ERROR,<span class="hljs-attr">error</span>:<span class="hljs-string">&quot;Deletion failed! &quot;</span>+error});<br/>                } <span class="hljs-keyword">else</span> {<br/>                    dispatch({<span class="hljs-attr">type</span>:C.DISPLAY_MESSAGE,<span class="hljs-attr">message</span>:<span class="hljs-string">&quot;Quote successfully deleted!&quot;</span>});<br/>                }<br/>            });<br/>        };<br/>    },<br/>    <span class="hljs-comment">// ...</span><br/>}</code></pre><p>As you can see, <code>startQuoteEdit</code> and <code>cancelQuoteEdit</code> are normal sync actions using regular plain action objects, while <code>deleteQuote</code> contains lots of logic doing both sync and async stuff. </p><p>When a <code>deleteQuote</code> action (which is a function) enters the <code>dispatch</code> chain, the <code>thunk</code> middleware will catch it, run it, and the result with be further calls to <code>dispatch</code> with (most often) regular action objects.</p><p>As you can imagine it is important to put <code>thunk</code> at the beginning of the middleware chain, since no other middleware will be expecting actions which are functions!</p><p>To further wrap our brains around this, let&#x27;s make a contrived experiment of our own using <code>thunk</code>. Let&#x27;s pretend-play that we&#x27;re a real app and define our action like this:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> actionCreators = {<br/>    <span class="hljs-attr">increase</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inc</span>)</span>{<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch,getState</span>)</span>{<br/>            dispatch({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENTINCOMING&#x27;</span>});<br/>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>                dispatch({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">by</span>:inc});<br/>            },<span class="hljs-number">1000</span>);<br/>        }<br/>    }<br/>}</code></pre><p>We&#x27;ll change the click hookup to look like this (although a &quot;real&quot; app would use a bridge of some kind and not a direct store reference):</p><pre><code class="hljs"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<br/>    store.dispatch( actionCreators.increase(<span class="hljs-number">1</span>) );<br/>});</code></pre><p>To see this in action we also make use of a simple <code>logger</code>:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> logger = <span class="hljs-function"><span class="hljs-keyword">function</span></span>(middlewareAPI){<br/>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span>(next){<br/>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span>(action){<br/>            <span class="hljs-keyword">var</span> ret = next(action),<br/>                <span class="hljs-keyword">new</span><span class="hljs-type">state</span> = middlewareAPI.getState();<br/>            output(<span class="hljs-string">&quot;action &quot;</span>+JSON.stringify(action)+<span class="hljs-string">&quot;, state now &quot;</span>+<span class="hljs-keyword">new</span><span class="hljs-type">state</span>);<br/>            <span class="hljs-keyword">return</span> ret;<br/>        }<br/>    }<br/>}</code></pre><p>We take care to put that <em>after</em> <code>thunk</code> in the middleware chain:</p><pre><code class="hljs">var middlewares = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Redux</span>.</span></span>apply<span class="hljs-constructor">Middleware(<span class="hljs-params">thunk</span>,<span class="hljs-params">logger</span>)</span>,<br/>    store = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Redux</span>.</span></span>create<span class="hljs-constructor">Store(<span class="hljs-params">reducer</span>,<span class="hljs-params">middlewares</span>)</span>;</code></pre><p>Check it out (standalone <a href="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/thunk.html">here</a>)!</p><iframe src="/static/posts/exploring-redux-middleware/applets/reduxmiddleware/experiments/thunk.html" height="150px" width="100%"></iframe><p>This use was rather contrived, but again, remember - the point of thunks as actions is merely to allow us to write asynchronous action creators without being dependent on a reference to the store.</p><h3 id="wrapping-up">Wrapping up</h3><p>I hope this little series of laboratory concoction was useful. Mind you, a good way to understand Redux is to read the source - it is tiny! In fact the full version with warnings and comments just has an ever so slightly larger character count than this blog post...</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/exploring-redux-middleware","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/exploring-redux-middleware" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/exploring-redux-middleware.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>