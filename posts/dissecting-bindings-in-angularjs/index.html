<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Dissecting @ &lt; &amp; = bindings in AngularJS</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/dissecting-bindings-in-angularjs.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Exploring how @ &lt; &amp; = really work in AngularJS directives/components, and realising how &lt; rules them all</div><hr/><h2>Dissecting @ &lt; &amp; = bindings in AngularJS</h2><p class="taglist">Tags:<!-- --> <a href="/tags/angularjs/">angularjs</a></p><div class="page-content"><div class="post" data-postid="angularjscomm"><h3 id="the-premise">The premise</h3><p>In AngularJS, when we define a component (or a directive), we can create inner scope variables from attributes. The API for doing so is rather convoluted:</p><pre><code class="hljs language-javascript">bindings: {<br/>  <span class="hljs-attr">attr1</span>: <span class="hljs-string">&#x27;@&#x27;</span>,<br/>  <span class="hljs-attr">attr2</span>: <span class="hljs-string">&#x27;&lt;&#x27;</span>,<br/>  <span class="hljs-attr">attr3</span>: <span class="hljs-string">&#x27;=&#x27;</span>,<br/>  <span class="hljs-attr">attr4</span>: <span class="hljs-string">&#x27;&amp;&#x27;</span><br/>}</code></pre><p>I got tired of paying the price of wrapping my brain around it every time I used, so in this post we will dissect the difference between the four symbols once and for all.</p><p>Specifically, we&#x27;ll...</p><ul><li>learn how to pass strings (<code>@</code>)</li><li>learn how to pass dynamic expressions (<code>&lt;</code>)</li><li>learn how to catch output (<code>&amp;</code>)</li><li>learn how to set up two-way data bindings (<code>=</code>)</li><li>learn how to do all of the above without using any of the four</li><li>learn why <code>&lt;</code> kicks the ass of the other three</li></ul><h3 id="reading-an-attribute-as-text">Reading an attribute as text</h3><p>Let&#x27;s start with <code>@</code>, the most straightforward of the four as it simply reads the attribute as text. In other words we <strong>pass a string</strong> to the component.</p><p>Say we have this component:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;readingstring&quot;</span>, {<br/>  <span class="hljs-attr">bindings</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;@&#x27;</span> },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;text: &lt;strong&gt;{{$ctrl.text}}&lt;/strong&gt;&lt;/p&gt;&#x27;</span><br/>});</code></pre><p>And we render it like this:</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">readingstring</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">readingstring</span>&gt;</span></code></pre><p>Then here is what we get:</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#stringviaat" style="height:50px;width:100%"></iframe><p>Using <code>@</code> creates an inner variable populated with the string content of the named attribute. You could say it serves as an <strong>initial config</strong> of the component.</p><h3 id="evaluating-an-attribute-as-an-expression">Evaluating an attribute as an expression</h3><p>More interesting is the need to evaluate an attribute as an expression, and have it reevaluated whenever the expression changes. Dynamic input!</p><p>We want to be able to do this...</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">dynamicinput</span> <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;outervariable&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dynamicinput</span>&gt;</span></code></pre><p>...and pass the evaluation of <code>outervariable</code> into <code>dynamicinput</code>.</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#inputfirst" style="height:90px;width:100%"></iframe><p>Prior to AngularJS 1.5, the only syntax we had for this was <code>=</code>:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;dynamicinput&quot;</span>,{<br/>  <span class="hljs-attr">bindings</span>: { <span class="hljs-attr">in</span>: <span class="hljs-string">&#x27;=&#x27;</span> },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;dynamic input: &lt;strong&gt;{{$ctrl.in}}&lt;/strong&gt;&lt;/p&gt;&#x27;</span><br/>});</code></pre><p>The downside of <code>=</code> was that it created a <strong>two-way data binding</strong>, even though we only needed a one-way. This also meant that the expression we pass in <strong>must be a variable</strong>. </p><p>But with AngularJS 1.5 we got <code>&lt;</code>, which means <strong>one-way data binding</strong>. This allows us to use any expression as input, such as a function call:</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">dynamicinput</span> <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;calculateSomething()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dynamicinput</span>&gt;</span></code></pre><p>The component implementation would be exactly the same, except changing <code>=</code> for <code>&lt;</code>.</p><h3 id="catching-output">Catching output</h3><p>Time to turn things around - how do we catch output from a component? See the tiny app below - the buttons are rendered in a child, and when they are clicked we want to update the outer value accordingly.</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#outputfirst" style="height:90px;width:100%"></iframe><p>This is where <code>&amp;</code> comes in. It <strong>interprets the attribute as a statement</strong> and <strong>wraps it in a function</strong>. The component can then call that function at will, and populate variables in the statement. Output to the parent!</p><p>If our outer html looks like this...</p><pre><code class="hljs language-html">Outer value: {{count}}<br/><span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">out</span>=<span class="hljs-string">&quot;count = count + amount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">output</span>&gt;</span></code></pre><p>..then an implementation of <code>output</code> using <code>&amp;</code> could look like this:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;output&quot;</span>,{<br/>  <span class="hljs-attr">bindings</span>: { <span class="hljs-attr">out</span>: <span class="hljs-string">&#x27;&amp;&#x27;</span> },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">`<br/>    &lt;button ng-click=&quot;$ctrl.out({amount: 1})&quot;&gt;buy one&lt;/button&gt;<br/>    &lt;button ng-click=&quot;$ctrl.out({amount: 5})&quot;&gt;buy many&lt;/button&gt; `</span><br/>});</code></pre><p>Note how we pass in an object with the variables to populate.  This convoluted syntax means that in order to use a component with an output we must know two things:</p><ul><li>the attribute name(s) to use</li><li>the names of the variables that will magically be created.</li></ul><p>Because <code>&amp;</code> is so convoluted, many use <code>=</code> to do output. By passing in the variable to be manipulated...</p><pre><code class="hljs language-html">Outer value: {{count}}<br/><span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">out</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">output</span>&gt;</span></code></pre><p>...we then simply change that variable inside the component:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;output&quot;</span>,{<br/>  <span class="hljs-attr">bindings</span>: { <span class="hljs-attr">out</span>: <span class="hljs-string">&#x27;=&#x27;</span> },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;<br/>    &lt;button ng-click=&quot;$ctrl.out = $ctrl.out + 1;&quot;&gt;buy one&lt;/button&gt;<br/>    &lt;button ng-click=&quot;$ctrl.out = $ctrl.out + 5;&quot;&gt;buy many&lt;/button&gt;<br/>  &lt;/div&gt;`</span><br/>});</code></pre><p>This really isn&#x27;t very pretty though:</p><ul><li>we&#x27;re again doing two-way data binding even though we only need one way</li><li>we might not want to save the output, but simply act on it</li></ul><p>A nicer solution than all of the above is to <strong>use <code>&lt;</code> to create output</strong> by <strong>passing in a callback</strong>!</p><p>We create the callback in the outer controller...</p><pre><code class="hljs language-javascript">$scope.callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">amount</span>)</span>{<br/>  $scope.count += amount;<br/>}</code></pre><p>...and pass it to the component:</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">out</span>=<span class="hljs-string">&quot;callback&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">output</span>&gt;</span></code></pre><p>The component now simply calls it accordingly:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;output&quot;</span>,{<br/>  <span class="hljs-attr">bindings</span>: { <span class="hljs-attr">out</span>: <span class="hljs-string">&#x27;&lt;&#x27;</span> },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">`<br/>    &lt;button ng-click=&quot;$ctrl.out(1)&quot;&gt;buy one&lt;/button&gt;<br/>    &lt;button ng-click=&quot;$ctrl.out(5)&quot;&gt;buy many&lt;/button&gt;`</span><br/>});</code></pre><p>Very similar to <code>&amp;</code>, but without the convoluted magic!</p><p>As an interesting aside, this pattern is exactly how output from a component works in React.</p><h3 id="two-way-data-binding">Two-way data binding</h3><p>This is where <code>=</code> is usually allowed to shine as an AngularJS poster boy. Take this app:</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#twowayeq" style="height:90px;width:100%"></iframe><p>If we render it like this...</p><pre><code class="hljs language-html">Outer: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ng-model</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span><br/><span class="hljs-tag">&lt;<span class="hljs-name">twoway</span> <span class="hljs-attr">connection</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">twoway</span>&gt;</span></code></pre><p>...then we can implement <code>twoway</code> using <code>=</code> like this:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;twowayeq&quot;</span>,{<br/>  <span class="hljs-attr">bindings</span>: { <span class="hljs-attr">connection</span>: <span class="hljs-string">&#x27;=&#x27;</span> },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">`inner: &lt;input ng-model=&quot;$ctrl.connection&quot;&gt;`</span><br/>});</code></pre><p>Admittedly easy, but note - it is rather rare to need two-way data binding. Often what you actually want is an input and an output.</p><p>Which brings us to how we can implement two-way binding using only <code>&lt;</code>! If we again create a callback function in the outer controller...</p><pre><code class="hljs language-javascript">$scope.callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newval</span>)</span>{<br/>  $scope.value = newval;<br/>}</code></pre><p>...and pass in both the value and the callback...</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">twoway</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">&quot;callback&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">twoway</span>&gt;</span></code></pre><p>...then the component can be created thusly:</p><pre><code class="hljs">app.component(<span class="hljs-string">&quot;twowayin&quot;</span>,{<br/>  bindings: {<br/>    value: <span class="hljs-string">&#x27;&lt;&#x27;</span>,<br/>    callback: <span class="hljs-string">&#x27;&lt;&#x27;</span><br/>  },<br/>  template: `<br/>     &lt;input <span class="hljs-attribute">ng-model</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$ctrl</span>.value&quot;</span> <span class="hljs-attribute">ng-change</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$ctrl</span>.callback(<span class="hljs-variable">$ctrl</span>.value)&quot;</span>&gt;<br/>  `<br/>});</code></pre><p>We have achieved two-way data binding, but we&#x27;re still adhering to a <strong>uni-directional data flow</strong>. Better karma!</p><h3 id="leaving-the-symbols-behind-alltogether">Leaving the symbols behind alltogether</h3><p>Fact is, the four symbols are just shortcuts. We can do all that they do without them.</p><p>The <strong>string passing app</strong>...</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#stringviaat" style="height:50px;width:100%"></iframe><p>...that we rendered like this...</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">readingstring</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">readingstring</span>&gt;</span></code></pre><p>...could be implemented by accessing the <code>$element</code> service:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;readingstring&quot;</span>, {<br/>  <span class="hljs-attr">controller</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$element</span>)</span>{<br/>    <span class="hljs-built_in">this</span>.text = $element.attr(<span class="hljs-string">&quot;text&quot;</span>);<br/>  },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;text: &lt;strong&gt;{{$ctrl.text}}&lt;/strong&gt;&lt;/p&gt;&#x27;</span><br/>});</code></pre><p>Or with a directive, by using the <code>attrs</code> that are passed to <code>link</code>:</p><pre><code class="hljs language-javascript">app.directive(<span class="hljs-string">&quot;readingstring&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>  <span class="hljs-keyword">return</span> {<br/>    <span class="hljs-attr">restrict</span>: <span class="hljs-string">&#x27;E&#x27;</span>,<br/>    <span class="hljs-attr">scope</span>: {},<br/>    <span class="hljs-attr">link</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope,elem,attrs</span>)</span>{<br/>      scope.text = attrs.text;<br/>    },<br/>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;text: &lt;strong&gt;{{text}}&lt;/strong&gt;&lt;/p&gt;&#x27;</span><br/>  };<br/>});</code></pre><p>The <strong>dynamic input</strong> app...</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#inputfirst" style="height:90px;width:100%"></iframe><p>...rendered like this...</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">dynamicinput</span> <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;outervariable&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dynamicinput</span>&gt;</span></code></pre><p>...could be implemented by using a <code>.$watch</code> call in the parent scope:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;dynamicinput&quot;</span>,{<br/>  <span class="hljs-attr">controller</span>: <span class="hljs-function">(<span class="hljs-params">$scope,$element</span>) =&gt;</span> {<br/>    <span class="hljs-keyword">let</span> expression = $element.attr(<span class="hljs-string">&quot;in&quot;</span>);<br/>    $scope.$parent.$watch(expression, <span class="hljs-function"><span class="hljs-params">newVal</span> =&gt;</span> $scope.in = newVal);<br/>  },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p&gt;dynamic input: &lt;strong&gt;{{in}}&lt;/strong&gt;&lt;/p&gt;&#x27;</span><br/>});</code></pre><p>The <strong>output app</strong>...</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#outputfirst" style="height:90px;width:100%"></iframe><p>...rendered like this...</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">out</span>=<span class="hljs-string">&quot;count = count + amount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">output</span>&gt;</span></code></pre><p>...could be implemented by calling <code>$scope.$apply</code> in the parent scope:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;output&quot;</span>,{<br/>  <span class="hljs-attr">controller</span>: <span class="hljs-function">(<span class="hljs-params">$scope,$element,$timeout</span>) =&gt;</span> {<br/>    <span class="hljs-keyword">let</span> statement = $element.attr(<span class="hljs-string">&quot;out&quot;</span>);<br/>    $scope.increaseBy = <span class="hljs-function"><span class="hljs-params">by</span> =&gt;</span> {<br/>      $timeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br/>        $scope.$parent.$apply(<span class="hljs-string">`amount = <span class="hljs-subst">${by}</span>; <span class="hljs-subst">${statement}</span>`</span>);<br/>      });<br/>    }<br/>  },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">`<br/>    &lt;button ng-click=&quot;increaseBy(1)&quot;&gt;buy one&lt;/button&gt;<br/>    &lt;button ng-click=&quot;increaseBy(5)&quot;&gt;buy many&lt;/button&gt;`</span><br/>});</code></pre><p>This isn&#x27;t exactly the same thing as <code>&amp;</code> since we have now also polluted the parent scope with an <code>amount</code> variable, but still, it shows the concept well enough.</p><p>Finally the <strong>two-way</strong> app...</p><iframe src="/static/posts/dissecting-bindings-in-angularjs/applets/angularcomm/index.html#twowayeq" style="height:90px;width:100%"></iframe><p>...rendered like with <code>=</code>...</p><pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">twoway</span> <span class="hljs-attr">connection</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">twoway</span>&gt;</span></code></pre><p>...could be implemented by setting a <code>$watch</code> in both parent and child scope:</p><pre><code class="hljs language-javascript">app.component(<span class="hljs-string">&quot;twoway&quot;</span>,{<br/>  <span class="hljs-attr">controller</span>: <span class="hljs-function">(<span class="hljs-params">$scope,$element,$timeout</span>) =&gt;</span> {<br/>    <span class="hljs-keyword">let</span> variable = $element.attr(<span class="hljs-string">&quot;connection&quot;</span>);<br/>    $scope.$parent.$watch(variable, <span class="hljs-function"><span class="hljs-params">newVal</span> =&gt;</span> $scope.inner = newVal;<br/>    $scope.$watch(<span class="hljs-string">&#x27;inner&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">newVal=<span class="hljs-string">&#x27;&#x27;</span></span>) =&gt;</span> $timeout( <span class="hljs-function">() =&gt;</span> {<br/>      $scope.$parent.$apply(<span class="hljs-string">`<span class="hljs-subst">${variable}</span> = &quot;<span class="hljs-subst">${newVal}</span>&quot;;`</span>);<br/>    }));<br/>  },<br/>  <span class="hljs-attr">template</span>: <span class="hljs-string">`inner: &lt;input ng-model=&quot;inner&quot;&gt;`</span><br/>});</code></pre><p>This is slight cheating since we&#x27;re now assuming the bound value to always be a string, but, the gist is still there!</p><h3 id="wrapping-up">Wrapping up</h3><p>We hope this journey has been educational, and that <code>@</code>, <code>&lt;</code>, <code>=</code> and <code>&amp;</code> now feel less intimidating.</p><p>And that you noticed how <code>&lt;</code> kicks the ass of the rest! It can do everything, which also <code>=</code> can, but <code>&lt;</code> looks much better doing it.</p><img src="/static/posts/dissecting-bindings-in-angularjs/img/angularjschart.png" style="margin-left:2em;max-width:400px"/><p>Both are somewhat clumsy for reading strings (<code>&lt;</code> requires a string in a string, and <code>=</code> needs a proxy variable), but that&#x27;s easy enough to do vanilla so <code>@</code> shouldn&#x27;t get too cocky.</p><p>Also, <code>&amp;</code> can go rotate on a stick.</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/dissecting-bindings-in-angularjs","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/dissecting-bindings-in-angularjs" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/dissecting-bindings-in-angularjs.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>