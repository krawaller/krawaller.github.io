<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Reflux refinement</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/reflux-refinement.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Looking at some improvements in newer Reflux versions</div><hr/><h2>Reflux refinement</h2><p class="taglist">Tags:<!-- --> <a href="/tags/react/">react</a><a href="/tags/reflux/">reflux</a></p><div class="page-content"><div class="post" data-postid="refluxrefinement"><h3 id="flux--reflux">Flux &gt; Reflux?</h3><p>In a <a href="/posts/react-js-architecture-flux-vs-reflux/">somewhat recent post</a> I walked through how much simpler the codebase of a small React app became when I switched out <a href="http://facebook.github.io/react/docs/flux-overview.html">Flux</a> for <a href="https://github.com/spoike/refluxjs">Reflux</a>.</p><p>However, I kind of glossed over that in one of the comparisons Flux actually &quot;won&quot; by a single LOC! It was the one comparing components listening to store changes:</p><pre><code class="hljs"><span class="hljs-comment">// Flux version</span><br/><span class="hljs-keyword">var</span> Cart = React.createClass({<br/>  componentDidMount:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{<br/>    appStore.addChangeListener(<span class="hljs-keyword">this</span>._onStuffChange)<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});<br/><br/><span class="hljs-comment">// Reflux version</span><br/><span class="hljs-keyword">var</span> Cart = React.createClass({<br/>  mixins: [Reflux.ListenerMixin],<br/>  componentDidMount: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<br/>    <span class="hljs-keyword">this</span>.listenTo(appStore, <span class="hljs-keyword">this</span>._onStuffChange);<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>In the Reflux we need the additional <code>mixins</code> row, which makes it even more boilerplaty than the Flux version!</p><h3 id="throwing-mixin-into-the-mixer">Throwing Mixin into the mixer</h3><p>Let&#x27;s take a peek at the internals of <code>ListenerMixin</code> to see what&#x27;s going on there. Here&#x27;s the full object:</p><pre><code class="hljs language-javascript">ListenerMixin = {<br/>    <span class="hljs-attr">componentWillMount</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br/>        <span class="hljs-built_in">this</span>.subscriptions = [];<br/>    },<br/>    <span class="hljs-attr">listenTo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">listenable, callback, defaultCallback</span>) </span>{<br/>        <span class="hljs-keyword">var</span> unsubscribe = listenable.listen(callback, <span class="hljs-built_in">this</span>);<br/>        <span class="hljs-built_in">this</span>.subscriptions.push(unsubscribe);<br/>        _.handleDefaultCallback(<span class="hljs-built_in">this</span>, listenable, defaultCallback);<br/>    },<br/>    <span class="hljs-attr">componentWillUnmount</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br/>        <span class="hljs-built_in">this</span>.subscriptions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">unsubscribe</span>) </span>{<br/>            unsubscribe();<br/>        });<br/>        <span class="hljs-built_in">this</span>.subscriptions = [];<br/>    }<br/>};</code></pre><p>As you can see it supplies the <code>listenTo</code> method we used, as well as two life cycle methods, <code>componentWillMount</code> and <code>componentWillUnmount</code>, dealing with setup and teardown of the listener.</p><p>Note the cleverness of the Reflux listenables - a call to their <code>listen</code> method returns an <code>unsubscribe</code> function, which takes care of all the cleanup for you when called.</p><h3 id="using-a-factory-call-as-a-mixin">Using a factory call as a mixin</h3><p>Looking at the source code got me thinking - why couldn&#x27;t the mixin provide the <code>componentDidMount</code> call too? Well, that&#x27;s where the call to <code>listenTo</code> happens, which needs a reference to the listenable and some callbacks.</p><p>So how about we give those to a factory instead, which then bakes out a mixin for us? After several iterations and thoughtful input from Reflux creator Mikael, we now have a mixin factory which imports the listening functionality and sets up the listener to the given listenable. </p><p>This means that this verbose Reflux version that lost to Flux...</p><pre><code class="hljs"><span class="hljs-keyword">var</span> Cart = React.createClass({<br/>  mixins: [Reflux.ListenerMixin],<br/>  componentDidMount: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<br/>    <span class="hljs-keyword">this</span>.listenTo(appStore, <span class="hljs-keyword">this</span>._onStuffChange);<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>...can now be reduced to this:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Cart = React.createClass({<br/>  <span class="hljs-attr">mixins</span>: [Reflux.listenTo(appStore,<span class="hljs-string">&#x27;_onStuffChange&#x27;</span>)],<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>Three lines shorter than the Flux version! Mission accomplished! </p><p>Note how we can&#x27;t use <code>this._onStuffChange</code> as an argument to the factory call, as <code>this</code> doesn&#x27;t point to the instance at this point in time.</p><p>The idea of using mixin factories have also been used in other places in the new Reflux version.</p><h3 id="connecting-state">Connecting state</h3><p>Consider what might be going on in <code>_onStuffChange</code> in the above example. A very common scenario when a React component listens to a Reflux Store is that we want to update the state of the component with the data sent from the store.</p><p>Since this is such a prevalent use case, Reflux now has a convenience method for this. Instead of the listenTo factory we can use the connect factory:</p><pre><code class="hljs"><span class="hljs-keyword">var</span> Cart = React.createClass({<br/>  mixins: [Reflux.connect(appStore)],<br/>  <span class="hljs-comment">// rest redacted (and doesn&#x27;t need to contain a callback at all)</span><br/>});</code></pre><p>This will set the state of the component to whatever is transmitted from the store. If you want the store data as a property of your state, you can instead do <code>connect(publisher,propname)</code>.</p><h3 id="much-wants-more">Much wants more</h3><p>The <a href="/posts/react-js-architecture-flux-vs-reflux/">previous post</a> also contained a Store comparison, which Reflux won by a wide margin. However, the winning code was still rather verbose:</p><pre><code class="hljs language-javascript">Reflux.createStore({<br/>  <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.addItem,_addItem);<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.removeItem,_removeItem);<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.increaseItem,_increaseItem);<br/>    <span class="hljs-built_in">this</span>.listenTo(actions.decreaseItem,_decreaseItem);<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>The new version introduces a <code>listenToMany</code> function which can be given an object where the values are publishers and the keys are assumed to correspond to methods on the listening object. If <code>_addItem</code>, <code>_removeItem</code> etc were local methods, that means the above code could be reduced to this:</p><pre><code class="hljs language-javascript">Reflux.createStore({<br/>  <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br/>    <span class="hljs-built_in">this</span>.listenToMany({<br/>        <span class="hljs-attr">_addItem</span>:actions.addItem,<br/>        <span class="hljs-attr">_removeItem</span>:actions.removeItem,<br/>        <span class="hljs-attr">_increaseItem</span>:actions.increaseItem,<br/>        <span class="hljs-attr">_decreaseItem</span>:actions.decreaseItem<br/>    );<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>Somewhat elegant, but still very noisy. However, if we change the callback names to correspond to the action names, we could simply do this:</p><pre><code class="hljs language-javascript">Reflux.createStore({<br/>  <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br/>    <span class="hljs-built_in">this</span>.listenToMany(actions);<br/>  },<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><p>Now things are really beginning to shine! As an added bonus you can call your method <code>onActionname</code>, and Reflux will realise it is a callback for <code>actionname</code>.</p><p>But we&#x27;re not done yet! We can make it leaner still through the new <code>listenables</code> property:</p><pre><code class="hljs language-javascript">Reflux.createStore({<br/>  <span class="hljs-attr">listenables</span>: actions,<br/>  <span class="hljs-comment">// rest redacted</span><br/>});</code></pre><h3 id="wrapping-up">Wrapping up</h3><p>What I&#x27;m really trying to say is this; Reflux has grown by leaps and bounds, meaning your code will shrink proportionally! Old API:s have gotten more powerful, and new functionality has been added.</p><p>I&#x27;m still amazed at the power of Mikael&#x27;s simpler Flux model, and if you haven&#x27;t tried Reflux out yet I strongly encourage you to do so!</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/reflux-refinement","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/reflux-refinement" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/reflux-refinement.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>