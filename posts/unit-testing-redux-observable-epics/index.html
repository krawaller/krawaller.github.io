<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" href="/static/styles/nprogress.css"/><link rel="stylesheet" href="/static/styles/code.css"/><link rel="stylesheet" href="/static/styles/site.css"/><link href="https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Lexend+Zetta&amp;display=swap" rel="stylesheet"/><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11433118-1', 'auto');
  ga("send", "pageview");</script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Unit testing Redux-observable epics</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/unit-testing-redux-observable-epics.js" as="script"/><link rel="preload" href="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ebbfd942159f83091516.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-c1620565ee9f1f33603c.js" as="script"/></head><body><div id="__next"><div style="margin-bottom:20px"></div><div class="master"><h1><a href="/"><span>k</span><span>r</span><span>a</span><span>w</span><span>a</span><span>l</span><span>l</span><span>e</span><span>r</span></a></h1><hr/><div class="summary">Demonstrating a convenient helper method and pattern for unit testing Redux observable epics</div><hr/><h2>Unit testing Redux-observable epics</h2><p class="taglist">Tags:<!-- --> <a href="/tags/redux/">redux</a><a href="/tags/redux-observable/">redux-observable</a><a href="/tags/testing/">testing</a><a href="/tags/jest/">jest</a><a href="/tags/typescript/">typescript</a></p><div class="page-content"><div class="post" data-postid="reduxobservabletesting"><h3 id="premise">Premise</h3><p>There are many different libraries for dealing with side effects in Redux. Right now my favourite is <a href="https://redux-observable.js.org/"><code>redux-observable</code></a> - the price of admission can be high since you need to buy into <a href="https://rxjs.dev/">RxJS</a> and reactive programming, but once you&#x27;re in the sailing is really smooth!</p><p>However, I initially had some troubles writing unit tests that I felt at ease with. The official docs didn&#x27;t help me much, and marble testing just felt like another layer without any real benefits.</p><p>After trying some different approaches I ended up with a rather simple helper, which will be introduced in this post!</p><h3 id="crash-test-dummy">Crash test dummy</h3><p>First we invent an imaginary epic to test! Say we have a Redux-controlled form where the user has rated something. A big button at the bottom will dispatch a <code>submitRating</code> action. Our epic now needs to...</p><ol><li>act on those actions</li><li>get the movieId from state (because the rating component doesn&#x27;t know it)</li><li>make a request to a service</li><li>dispatch a success/fail action</li></ol><p>Such an epic could look something like this:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> submitRatingEpic: AppEpic = <span class="hljs-function">(<span class="hljs-params">action$, state$, deps</span>) =&gt;</span><br/>  action$.pipe(<br/>    filter(isSubmitRatingStartAction),<br/>    withLatestFrom(state$),<br/>    switchMap(<span class="hljs-function">(<span class="hljs-params">[action, state]</span>) =&gt;</span><br/>      <span class="hljs-keyword">from</span>(<br/>        deps<br/>          .submitRating(state.ui.currentMovieId, action.rating)<br/>          .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> [<span class="hljs-literal">null</span>, res])<br/>          .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> [err, <span class="hljs-literal">null</span>])<br/>      )<br/>    ),<br/>    map(<span class="hljs-function">(<span class="hljs-params">[err, res]</span>) =&gt;</span><br/>      err ? submitRatingError(err) : submitRatingFinish(res)<br/>    )<br/>  );</code></pre><p>For TypeScript users; my <code>AppEpic</code> type is a simple helper type looking something like this:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { Epic } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-observable&quot;</span>;<br/><span class="hljs-keyword">import</span> {<br/>  AppAction, <span class="hljs-comment">// a union of all action types</span><br/>  AppState, <span class="hljs-comment">// typings for the full</span><br/>  EpicDeps <span class="hljs-comment">// the dependency object given to all epics</span><br/>} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../types&quot;</span>;<br/><br/><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AppEpic = Epic&lt;AppAction, AppAction, AppState, EpicDeps&gt;;</code></pre><p>The contents of the <code>AppAction</code> union are all extensions of a basic <code>Action</code> type:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Action&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, P&gt; = {<br/>  <span class="hljs-keyword">type</span>: T;<br/>  payload: P;<br/>};</code></pre><h3 id="using-the-helper">Using the helper</h3><p>To write tests we need to be able to do the following:</p><ul><li>emit on <code>action$</code></li><li>emit on <code>state$</code></li><li>provide dependencies</li><li>see what the epic emits at any point in time</li></ul><p>The helper does exactly this with a very simple API - you simply call a <code>testEpic</code> function, typically once per unit test:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> {<br/>  emitAction, <span class="hljs-comment">// will emit to action$</span><br/>  emitState, <span class="hljs-comment">// will emit to state$</span><br/>  epicEmissions <span class="hljs-comment">// a mutating array of emissions from the epic</span><br/>} = testEpic(submitRatingEpic, fakeDeps);</code></pre><p>A test would then typically look something like this:</p><pre><code class="hljs language-typescript"><span class="hljs-comment">// act</span><br/>emitState(someFakeState);<br/>emitAction(someFakeAction);<br/><br/><span class="hljs-comment">// assert</span><br/>expect(epicEmissions).toHaveLength(<span class="hljs-number">1</span>);<br/>expect(isSomeAction(epicEmissions[<span class="hljs-number">0</span>])).toBe(<span class="hljs-literal">true</span>);<br/>expect(epicEmissions[<span class="hljs-number">0</span>].payload).toEqual(expectedPayload);</code></pre><h3 id="applying-the-helper">Applying the helper</h3><p>Let&#x27;s examing what this would look like when testing <code>submitRatingEpic</code>!</p><h4 id="arranging-the-test"><em>Arranging</em> the test</h4><p>First we do some setup! We need...</p><ol><li><p>a fake service:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> fakeReply = { fake: <span class="hljs-string">&quot;reply&quot;</span> };<br/><span class="hljs-keyword">const</span> fakeService = jest.fn(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(fakeReply));<br/><span class="hljs-keyword">const</span> fakeDeps: Partial&lt;EpicDeps&gt; = {<br/>  submitRating: fakeService<br/>};</code></pre></li><li><p>some fake data:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> fakeMovieId = <span class="hljs-string">&quot;FAKE_MOVIE_ID&quot;</span>;<br/><span class="hljs-keyword">const</span> fakeRating = <span class="hljs-number">666</span>;<br/><span class="hljs-keyword">const</span> defaultAppState = getDefaultAppState();<br/><span class="hljs-keyword">const</span> fakeAppState = {<br/>  ...defaultAppState,<br/>  ui: {<br/>    ...defaultAppState.ui,<br/>    currentMovieId: fakeMovieId<br/>  }<br/>};</code></pre></li><li><p>an epic instance to test! This is where our helper method comes into play:</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> { epicEmissions, emitState, emitAction } = testEpic(<br/>  submitRatingEpic,<br/>  fakeDeps<br/>);</code></pre></li></ol><h4 id="acting-out-the-test"><em>Acting</em> out the test</h4><p>Now to finally make stuff happen! We need to...</p><ol><li><p>emit our fake state with the fakeMovieId:</p><pre><code class="hljs language-typescript">emitState(fakeAppState);</code></pre></li><li><p>emit the action that we want to see the epic react to:</p><pre><code class="hljs language-typescript">emitAction(submitRatingStart(fakeRating));</code></pre><p>Here <code>submitRatingStart</code> is a simple action creator. We could of course also inline an object literal, but using the action creators that we already have makes the test more readable!</p></li></ol><p>Note that the order here matters - since the epic will fetch the current movie id from the current state, that state needs to already be there when the action triggers the epic.</p><h4 id="asserting-things-went-ok"><em>Asserting</em> things went ok</h4><p>The final piece of the puzzle is to make assertions against <code>epicEmissions</code>, to test that the epic has emitted the correct action:</p><pre><code class="hljs language-typescript">expect(epicEmissions).toHaveLength(<span class="hljs-number">1</span>);<br/><span class="hljs-keyword">const</span> action = epicEmissions[<span class="hljs-number">0</span>];<br/>expect(isSubmitRatingFinish(action)).toBe(<span class="hljs-literal">true</span>);<br/>expect(action.payload).toEqual({<br/>  movieId: fakeMovieId,<br/>  rating: fakeRating<br/>});</code></pre><p>No need for cumbersome subscriptions to throwaway observables, or any such shenanigans. Simply inspect the contents of <code>epicEmissions</code>!</p><p>For more complex tests we might do more state and/or action emissions, and test the contents of <code>epicEmissions</code> at several points during that.</p><h3 id="helper-source-code">Helper source code</h3><p>There isn&#x27;t much to the source of the helper! It mainly consists of instantiating fake <code>ActionsObservable</code> and <code>StateObservable</code> that <code>redux-observable</code> will use to create <code>action$</code> and <code>state$</code> for the individual epics.</p><pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rxjs&quot;</span>;<br/><span class="hljs-keyword">import</span> { ActionsObservable, StateObservable, Epic } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-observable&quot;</span>;<br/><br/><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> testEpic = &lt;A <span class="hljs-keyword">extends</span> Action&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;, S, D&gt;(<br/>  epic: Epic&lt;A, A, S, D&gt;, <span class="hljs-comment">// A, S, D will be inferred from here</span><br/>  deps: Partial&lt;D&gt; = <span class="hljs-function">(<span class="hljs-params">{} <span class="hljs-keyword">as</span> unknown</span>) <span class="hljs-params">as</span> <span class="hljs-params">D</span><br/>) =&gt;</span> {<br/>  <span class="hljs-keyword">const</span> actionSubject = <span class="hljs-keyword">new</span> Subject&lt;A&gt;();<br/>  <span class="hljs-keyword">const</span> action$ = <span class="hljs-keyword">new</span> ActionsObservable(actionSubject);<br/>  <span class="hljs-keyword">const</span> emitAction = actionSubject.next.bind(actionSubject);<br/><br/>  <span class="hljs-keyword">const</span> stateSubject = <span class="hljs-keyword">new</span> Subject&lt;S&gt;();<br/>  <span class="hljs-keyword">const</span> state$ = <span class="hljs-keyword">new</span> StateObservable(stateSubject, (<span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> unknown) <span class="hljs-keyword">as</span> S);<br/>  <span class="hljs-keyword">const</span> emitState = stateSubject.next.bind(stateSubject);<br/><br/>  <span class="hljs-keyword">const</span> epicEmissions: A[] = [];<br/>  epic(action$, state$, deps <span class="hljs-keyword">as</span> D).subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> epicEmissions.push(e));<br/><br/>  <span class="hljs-keyword">return</span> { emitAction, emitState, epicEmissions };<br/>};</code></pre><p>The regular JS versions for the non-enlightened:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rxjs&quot;</span>;<br/><span class="hljs-keyword">import</span> { ActionsObservable, StateObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-observable&quot;</span>;<br/><br/><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> testEpic = <span class="hljs-function">(<span class="hljs-params">epic, deps = {}</span>) =&gt;</span> {<br/>  <span class="hljs-keyword">const</span> actionSubject = <span class="hljs-keyword">new</span> Subject();<br/>  <span class="hljs-keyword">const</span> action$ = <span class="hljs-keyword">new</span> ActionsObservable(actionSubject);<br/>  <span class="hljs-keyword">const</span> emitAction = actionSubject.next.bind(actionSubject);<br/><br/>  <span class="hljs-keyword">const</span> stateSubject = <span class="hljs-keyword">new</span> Subject();<br/>  <span class="hljs-keyword">const</span> state$ = <span class="hljs-keyword">new</span> StateObservable(stateSubject, <span class="hljs-literal">null</span>);<br/>  <span class="hljs-keyword">const</span> emitState = stateSubject.next.bind(stateSubject);<br/><br/>  <span class="hljs-keyword">const</span> epicEmissions = [];<br/>  epic(action$, state$, deps).subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> epicEmissions.push(e));<br/><br/>  <span class="hljs-keyword">return</span> { emitAction, emitState, epicEmissions };<br/>};</code></pre><h3 id="wrapping-up">Wrapping up</h3><p>For me, exchanging marble testing and my other convoluted attempts for this helper made my epic tests aeons easier to read, write and maintain. My hope is that you will have the same experience!</p></div><hr/></div><div id="disqus_thread" style="display:none"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/posts/unit-testing-redux-observable-epics","query":{},"buildId":"wQeVqw4-MCmoY2Zy_p65E","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/posts/unit-testing-redux-observable-epics" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/posts/unit-testing-redux-observable-epics.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/wQeVqw4-MCmoY2Zy_p65E/pages/_app.js"></script><script src="/_next/static/runtime/webpack-3df6523e264ff2ac6548.js" async=""></script><script src="/_next/static/chunks/commons.ebbfd942159f83091516.js" async=""></script><script src="/_next/static/runtime/main-c1620565ee9f1f33603c.js" async=""></script><script type="text/javascript" async="" src="https://krawaller.disqus.com/embed.js"></script></body></html>